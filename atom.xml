<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耗子的博客</title>
  
  
  <link href="https://mouse0w0.github.io/atom.xml" rel="self"/>
  
  <link href="https://mouse0w0.github.io/"/>
  <updated>2025-05-20T11:48:56.964Z</updated>
  <id>https://mouse0w0.github.io/</id>
  
  <author>
    <name>Mouse0w0</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Minecraft Forge中使用Mixin</title>
    <link href="https://mouse0w0.github.io/2022/03/01/Mixins-on-Minecraft-Forge/"/>
    <id>https://mouse0w0.github.io/2022/03/01/Mixins-on-Minecraft-Forge/</id>
    <published>2022-03-01T15:00:00.000Z</published>
    <updated>2025-05-20T11:48:56.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Mixins-on-Minecraft-Forge">Mixins on Minecraft Forge</a></p></blockquote><p>Mixin现在作为库与<a href="https://www.minecraftforge.net/">Minecraft Forge</a>一同发布，这意味着不再需要像传统版本那样，将Mixin嵌入到模组Jar中。实际上，这样做会引发问题。</p><p>如<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Obfuscation-and-Mixins">混淆与Mixin</a>一章中所述，当你为生产环境构建模组时，某些Mixin功能需要特殊处理才能跨越<em>混淆边界</em>。本指南说明了如何在Forge UserDev环境中使用Mixin功能，以及如何配置构建，以便为Mixin正确生成混淆信息。</p><p>本指南假定你已经创建了一个<strong>包（Package）</strong>来包含你的Mixin和一个<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---The-Mixin-Environment#mixin-configuration-files">Mixin配置</a>来声明Mixin和选项。</p><p>为了配置要在开发中运行的项目，我们将对<code>build.gradle</code>进行如下更改，并管理混淆：</p><ol><li>添加<a href="https://github.com/SpongePowered/MixinGradle">MixinGradle</a>插件。</li><li>添加Mixin<strong>注解处理器（Annotation Processor）</strong>依赖。</li><li>通过<code>mixin</code>闭包（Closure）为<strong>MixinGradle</strong>配置选项。</li></ol><blockquote><p>在本指南中，将假定你的Mixin配置名为<code>mixins.mymod.json</code>，而refmap被命名为<code>mixins.mymod.refmap.json</code>，并且你只使用了<code>main</code>源代码集（SourceSet）。</p></blockquote><h2 id="步骤-1-添加MixinGradle插件"><a href="#步骤-1-添加MixinGradle插件" class="headerlink" title="步骤 1 - 添加MixinGradle插件"></a>步骤 1 - 添加MixinGradle插件</h2><p>打开你的<code>build.gradle</code>文件并在文件顶部找到<code>buildscript</code>块。在<code>buildscript</code>块内的<code>repositories</code>块的正下方是<code>dependencies</code>块，它指定了构建脚本本身（而不是项目）所需的依赖关系。我们将添加<strong>MixinGradle</strong>依赖项，以便加载插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="attr">group:</span> <span class="string">&#x27;net.minecraftforge.gradle&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;ForgeGradle&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;5.1.+&#x27;</span>, <span class="attr">changing:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 添加 MixinGradle 插件</span></span><br><span class="line">        classpath <span class="string">&#x27;org.spongepowered:mixingradle:0.7.+&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经注册了依赖项，我们可以将插件应用到我们的构建中。在<code>buildscript</code>块的正下方，你将看到已经应用了三个插件。我们将在现有插件下面添加<strong>MixinGradle</strong>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;net.minecraftforge.gradle&#x27;</span></span><br><span class="line"><span class="comment">// Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;eclipse&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line"><span class="comment">// 应用 MixinGradle 插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;org.spongepowered.mixin&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="步骤-2-添加Mixin注解处理器"><a href="#步骤-2-添加Mixin注解处理器" class="headerlink" title="步骤 2 - 添加Mixin注解处理器"></a>步骤 2 - 添加Mixin注解处理器</h2><p><strong>MixinGradle</strong>的工作是<em>配置</em>Mixin注解处理器（AP），但是AP不是自动应用的，我们需要将其作为依赖项添加。AP依赖项应该与项目中使用的版本相同或更高（如果不确定使用的是哪个版本的Mixin，请参阅本指南末尾的部分）。</p><p>要将Mixin AP依赖项添加到项目中，请找到该项目的<code>dependencies</code>块。<strong>这_不是_Gradle文件顶部<code>buildscript</code>块中的<code>dependencies</code>块，而是文件下面更大的<code>dependencies</code>块。</strong>在本指南中，我们假定版本为<code>0.8.5</code>（撰写本文时的当前版本）。</p><p>它当前应该包含<code>minecraft</code>依赖项和一组注释，以及您手动添加的任何其它依赖项。<code>main</code>的AP配置称为<code>annotationProcessor</code>。将Mixin AP依赖项添加到<code>dependencies</code>块：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Specify the version of Minecraft to use. If this is any group other than &#x27;net.minecraft&#x27;, it is assumed</span></span><br><span class="line">    <span class="comment">// that the dep is a ForgeGradle &#x27;patcher&#x27; dependency, and its patches will be applied.</span></span><br><span class="line">    <span class="comment">// The userdev artifact is a special name and will get all sorts of transformations applied to it.</span></span><br><span class="line">    minecraft <span class="string">&#x27;net.minecraftforge:forge:1.17.1-37.0.70&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用 Mixin AP</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.spongepowered:mixin:0.8.5:processor&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，AP依赖项含有额外的<em>分类词</em><code>processor</code>。这是一个特殊的臃肿Jar（Fat Jar），其中包含Mixin AP所需的上游依赖项，因此你不必手动指定它们。</p></blockquote><h3 id="步骤-2-1-如果你有其它含有Mixin的源代码集"><a href="#步骤-2-1-如果你有其它含有Mixin的源代码集" class="headerlink" title="步骤 2.1 - 如果你有其它含有Mixin的源代码集"></a>步骤 2.1 - 如果你有其它含有Mixin的源代码集</h3><p><em>如果你只有一个源代码集（SourceSet）<code>main</code>，你可以跳过本节。</em></p><p>额外的源代码集将有相应的<em>Gradle配置</em>，用于定义它们的依赖关系。如果你有其它含有Mixin的源代码集，那么每个源代码集都需要自己的<strong>参考映射（Reference Map）</strong>（下面将详细介绍），每个源代码集都需要配置Mixin AP依赖项。</p><p>让我们假定你有额外的名为<code>client</code>和<code>api</code>的源代码集。相应的配置名称将是<code>clientAnnotationProcessor</code>和<code>apiAnnotationProcessor</code>，将Mixin AP添加到其中：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Specify the version of Minecraft to use. If this is any group other than &#x27;net.minecraft&#x27;, it is assumed</span></span><br><span class="line">    <span class="comment">// that the dep is a ForgeGradle &#x27;patcher&#x27; dependency, and its patches will be applied.</span></span><br><span class="line">    <span class="comment">// The userdev artifact is a special name and will get all sorts of transformations applied to it.</span></span><br><span class="line">    minecraft <span class="string">&#x27;net.minecraftforge:forge:1.17.1-37.0.70&#x27;</span></span><br><span class="line"></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.spongepowered:mixin:0.8.5:processor&#x27;</span></span><br><span class="line">    clientAnnotationProcessor <span class="string">&#x27;org.spongepowered:mixin:0.8.5:processor&#x27;</span></span><br><span class="line">    apiAnnotationProcessor <span class="string">&#x27;org.spongepowered:mixin:0.8.5:processor&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="步骤-3-配置MixinGradle"><a href="#步骤-3-配置MixinGradle" class="headerlink" title="步骤 3 - 配置MixinGradle"></a>步骤 3 - 配置MixinGradle</h2><p><strong>MixinGradle</strong>提供了一个名为<code>mixin</code>的<em>扩展</em>，允许我们配置插件的选项，<strong>MixinGradle</strong>然后将这些设置应用到适当的位置。要配置扩展，请指定扩展名和包含我们设置的闭包。这可以放在构建中的任何地方，但我建议将其放在<code>sourceSets</code>或<code>dependencies</code>块之后：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mixin &#123;</span><br><span class="line">    <span class="comment">// MixinGradle 设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要设置"><a href="#重要设置" class="headerlink" title="重要设置"></a>重要设置</h3><p><strong>MixinGradle</strong>可以配置AP选项，但我们需要告诉它要为每个编译任务生成的refmap的名称，这必须与配置JSON中的refmap名称相对应。</p><blockquote><p>请注意，同一源代码集中的配置都应该指定相同的refmap名称，而不管它们包含哪些Mixin。这是因为refmap与SourceSet的compile任务耦合在一起，而不关心你的配置中的Mixin的组织方式。</p></blockquote><p>我们还可以指定Mixin配置的名称，这将执行两个任务：</p><ul><li>配置将被注入到我们所有的<em>运行配置</em>中。</li><li>配置名称将添加到所有混淆Jar的Manifest中（在<code>MixinConfigs</code>键中）。</li></ul><p>让我们将<code>main</code>源代码集的refmap名称和配置名称添加到<code>mixin</code>闭包中：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mixin &#123;</span><br><span class="line">    <span class="comment">// MixinGradle 设置</span></span><br><span class="line">    add sourceSets.main, <span class="string">&#x27;mixins.mymod.refmap.json&#x27;</span></span><br><span class="line">    config <span class="string">&#x27;mixins.mymod.json&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实用设置"><a href="#实用设置" class="headerlink" title="实用设置"></a>实用设置</h3><p><code>mixin</code>闭包也可用于配置选项，如Mixin<a href="https://github.com/SpongePowered/Mixin/wiki/Mixin-Java-System-Properties">系统属性</a>（用于开发运行）和<em>Mixin注解处理器</em>的选项。例如，我建议在开发期间设置<code>mixin.debug.verbose</code>和<code>mixin.debug.export</code>。为了方便起见，我们可以在<code>mixin</code>闭包中设置这些属性：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mixin &#123;</span><br><span class="line">    <span class="comment">// MixinGradle 设置</span></span><br><span class="line">    add sourceSets.main, <span class="string">&#x27;mixins.mymod.refmap.json&#x27;</span></span><br><span class="line">    config <span class="string">&#x27;mixins.mymod.json&#x27;</span></span><br><span class="line"></span><br><span class="line">    debug.verbose = <span class="literal">true</span></span><br><span class="line">    debug.export = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在更改影响运行配置的任何设置后，请记住使用<code>genEclipseRuns</code>，<code>genIntellijRuns</code>或<code>genVSCodeRuns</code>任务重新生成运行配置！</p></blockquote><h3 id="步骤-4-1-如果你有其它含有Mixin的源代码集"><a href="#步骤-4-1-如果你有其它含有Mixin的源代码集" class="headerlink" title="步骤 4.1 - 如果你有其它含有Mixin的源代码集"></a>步骤 4.1 - 如果你有其它含有Mixin的源代码集</h3><p><em>如果你只有一个源代码集（SourceSet）<code>main</code>，你可以跳过本节。</em></p><p>除了<em>Gradle配置</em>，项目中的每一个源代码集都会获得一个对应的<em>Java编译任务</em>，它以源代码集命名。由于每个源代码集都是单独编译的，AP每次都会单独运行，因此每个源代码集都需要一个单独的<em>参考映射</em>（refmap）。基于上面的示例，让我们为<code>client</code>和<code>api</code>源代码集添加refmap名和配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mixin &#123;</span><br><span class="line">    add sourceSets.main, <span class="string">&#x27;mixins.mymod.refmap.json&#x27;</span></span><br><span class="line">    add sourceSets.client, <span class="string">&#x27;mixins.mymod.client.refmap.json&#x27;</span></span><br><span class="line">    add sourceSets.api, <span class="string">&#x27;mixins.mymod.api.refmap.json&#x27;</span></span><br><span class="line"></span><br><span class="line">    config <span class="string">&#x27;mixins.mymod.json&#x27;</span></span><br><span class="line">    config <span class="string">&#x27;mixins.mymod.client.json&#x27;</span></span><br><span class="line">    config <span class="string">&#x27;mixins.mymod.api.json&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解处理器选项"><a href="#注解处理器选项" class="headerlink" title="注解处理器选项"></a>注解处理器选项</h2><p><strong>MixinGradle</strong>使用所有必需的选项配置AP。但是，Mixin AP选项可以通过<code>mixin</code>闭包进行操纵。以下是一些实用选项：</p><dl>  <dt>boolean <tt>disableTargetValidator</tt></dt>  <dd>禁用目标验证器（验证Mixin目标是否合理（例如，目标层次结构中存在超类））</dd>  <dt>boolean <tt>disableOverwriteChecker</tt></dt>  <dd>禁用重写方法检查器，它用来确保<tt>&#64;Overwrite</tt>方法的JavaDoc含有<tt>&#64;author</tt>和<tt>&#64;reason</tt>标记</dd>  <dt>String <tt>overwriteErrorLevel</tt></dt>  <dd>为重写方法检查器设置错误级别（默认为<tt>warning</tt>，可以被设置为<tt>error</tt>）</dd></dl><dl>  <dt><tt>quiet</tt></dt>  <dd>抑制来自AP的突出消息和信息输出</dd>  <dt><tt>extraMappings</tt></dt>  <dd>指定要提供给AP的附加（自定义）TRSG映射文件的名称，这可用于主映射文件中未指定的映射项</dd></dl><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mixin &#123;</span><br><span class="line">    <span class="comment">// AP 设置</span></span><br><span class="line">    disableTargetValidator = <span class="literal">true</span></span><br><span class="line">    overwriteErrorLevel = <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    quiet</span><br><span class="line">    extraMappings file(<span class="string">&quot;my_custom_srgs.tsrg&quot;</span>)</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="带有选项的mixin闭包示例"><a href="#带有选项的mixin闭包示例" class="headerlink" title="带有选项的mixin闭包示例"></a>带有选项的<code>mixin</code>闭包示例</h2><p>下面是一个完整的例子，展示了一旦我们配置了所有内容，<code>mixin</code>闭包可能会是什么样子：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mixin &#123;</span><br><span class="line">    <span class="comment">// 每个源代码集的refmap</span></span><br><span class="line">    add sourceSets.main, <span class="string">&#x27;mixins.mymod.refmap.json&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置将添加到每个运行配置和Jar</span></span><br><span class="line">    config <span class="string">&#x27;mixins.mymod.json&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定开发环境运行配置的选项</span></span><br><span class="line">    debug.verbose = <span class="literal">true</span></span><br><span class="line">    debug.export = <span class="literal">true</span></span><br><span class="line">    dumpTargetOnFailure = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解处理器的选项</span></span><br><span class="line">    quiet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何找到Mixin版本"><a href="#如何找到Mixin版本" class="headerlink" title="如何找到Mixin版本"></a>如何找到Mixin版本</h2><p>如果你不确定项目中使用的是哪个版本的Mixin，可以通过以下几种方式找到它：</p><ol><li>在IDE中，检查项目的依赖项列表。例如，在Eclipse中，你可以在<code>Project and External Dependencies</code>容器中查看。</li><li><p>使用<code>gradle dependencies</code>任务将项目的依赖关系树发送到控制台，并使用<code>find</code>（在Windows上）或<code>grep</code>（在Linux上）对其进行过滤：</p><pre><code>gradlew --console=plain dependencies | find &quot;mixin&quot;</code></pre><p>这应该会向控制台发出几行代码，辨识Mixin依赖版本应该不会太难。</p></li><li>在开发环境中运行游戏，然后搜索<code>debug.log</code>，查找<code>mixin subsystem version</code>。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Mixins-on-Minecraft-Forge&quot;&gt;Mixins on Minecraft Forge&lt;/a&gt;&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
    <category term="Forge" scheme="https://mouse0w0.github.io/tags/Forge/"/>
    
  </entry>
  
  <entry>
    <title>Mixin参考——Mixin Java系统属性</title>
    <link href="https://mouse0w0.github.io/2022/03/01/Mixin-Java-System-Properties/"/>
    <id>https://mouse0w0.github.io/2022/03/01/Mixin-Java-System-Properties/</id>
    <published>2022-03-01T07:00:00.000Z</published>
    <updated>2025-05-20T11:48:56.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Mixin-Java-System-Properties">Mixin Java System Properties</a></p></blockquote><p>下表汇总了Mixin支持的<code>Java系统属性</code>，以启用各种调试和审计功能。将任何属性设置为<code>true</code>以启用该选项：</p><table width="100%">  <thead>    <tr>      <th>系统属性</th><th>描述</th>    </tr>  </thead>  <tbody>    <tr>      <td valign="top"><code>mixin.debug</code></td>      <td valign="top">启用<b>所有</b>Mixin调试选项</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.export</code></td>      <td valign="top">        <code>export</code>调试选项使Mixin处理器为所有Mixin目标向磁盘导出混入后的字节码。字节码被输出到你的运行目录下的<code>.mixin.out</code>文件夹下的典型包/类结构中。        <p>将Fernflower的jar放在运行时类路径上时也会导致这些类文件被反编译。</p>      </td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.export.filter</code></td>      <td valign="top">导出过滤器，如果为缺省值，允许导出所有转换的类。如果指定值，则作为要导出的类名的过滤器，并且只导出匹配的类。这在使用Fernflower时非常有用，否则导出可能非常慢。允许使用以下通配符。      <dl>        <dt>*</dt><dd>匹配除点（.）以外的一个或多个字符</dd>        <dt>**</dt><dd>匹配任意数量的字符</dd>        <dt>?</dt><dd>仅匹配一个字符</dd>      </dl></td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.export.decompile</code></td>      <td valign="top">如果设置为false，即使在类路径上找到Fernflower，也会禁用它。</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.export.decompile.async</code></td>      <td valign="top">在单独的线程中运行Fernflower。一般来说，这将使导出对启动耗时的影响降低（反编译通常会增加大约20%的加载时间），同时注意崩溃可能导致导出未反编译。</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.verify</code></td>      <td valign="top"><code>verify</code>选项在混入后的字节码上运行ASM的<code>CheckClassAdapter</code>以检查是否正确应用了Mixin转换。此选项仅用于Mixin库，不建议在Mixin的常规调试期间启用。</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.verbose</code></td>      <td valign="top"><code>verbose</code>选项将Mixin处理器生成的所有<code>DEBUG</code>级别日志消息提升到<code>INFO</code>级别，以便在运行时将它们发送到控制台。当使用Mixin开发时，这是一个非常有用的选项，因为它允许对Mixin应用进程进行更交互式的监控。</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.countInjections</code></td>      <td valign="top">将失败的注入提升到错误状态。详细信息请参见<a href="http://jenkins.liteloader.com/job/Mixin/javadoc/org/spongepowered/asm/mixin/injection/Inject.html#expect--"><code>Inject.expect</code></a>。</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.strict</code></td>      <td valign="top">启用严格检查。</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.strict.unique</code></td>      <td valign="top">如果为false（默认值），<a href="http://jenkins.liteloader.com/job/Mixin/javadoc/org/spongepowered/asm/mixin/Unique.html">Unique</a>公共方法仅在遇到问题时发出警告，不会合并到目标中。如果为true，则会抛出异常。</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.strict.targets</code></td>      <td valign="top">启用对Mixin目标的严格检查。</td>    </tr>    <tr>      <td valign="top"><code>mixin.debug.profiler</code></td>      <td valign="top">为所有Mixin操作启用性能分析器（通常仅在Mixin准备操作期间启用）。</td>    </tr>    <tr>      <td valign="top"><code>mixin.dumpTargetOnFailure</code></td>      <td valign="top">有时，Mixin会失败，并显示一条神秘的消息，例如目标中不存在影子目标，或其他意外错误，这表明目标类未处于特定Mixin预期的状态。有时，这可能是因为另一个转换器正在以Mixin转换器无法预料的方式对字节码进行转换，或者目标类发生了其它意外的更改。启用此选项会导致<code>InvalidMixinException</code>和其他运行时Mixin错误，从而将<i>传入的</i>（未经混入的）类字节码转储到磁盘。这可以使用<code>javap</code>或其它Java反汇编程序检查目标类字节码，以确定不匹配的原因。</td>    </tr>    <tr>      <td valign="top"><code>mixin.checks</code></td>      <td valign="top">启用<b>所有</b>Mixin检查操作</td>    </tr>    <tr>      <td valign="top"><code>mixin.checks.interfaces</code></td>      <td valign="top">        <p>启用<i>接口实现审计模式</i>。启用此模式后，Mixin处理器将为每个应用的Mixin输出一个审计报告，该报告提供了由类方法声明但<i>未由类或任何超类实现</i>的接口方法的摘要，实际上，那些方法在被调用时会导致抛出<code>AbstractMethodError</code>。</p>        <p>报告被生成到<code>标准错误（STDERR）</code>输出，也会写入你的运行目录下的<code>.mixin.out</code>文件夹下的平面文件。</p>      </td>    </tr>    <tr>      <td valign="top"><code>mixin.checks.interfaces.strict</code></td>      <td valign="top">如果启用了接口检查，“严格模式”（默认）会将实现检查应用于抽象目标类。将此选项设置为<code>false</code>会导致在生成实现报告时跳过抽象目标。</td>    </tr>    <tr>      <td valign="top"><code>mixin.ignoreConstraints</code></td>      <td valign="top">禁用<em>约束检查</em>，将违反约束的情况从致命错误降级为仅输出警告。用于开发或out-of-band目标的in-the-wild测试</td>    </tr>    <tr>      <td valign="top"><code>mixin.hotSwap</code></td>      <td valign="top">启用热插拔代理。</td>    </tr>    <tr>      <td valign="top"><code>mixin.env</code></td>      <td valign="top">环境设置的父级。实际上并不是一个设置。总是为<code>false</code>。</td>    </tr>    <tr>      <td valign="top"><code>mixin.env.obf</code></td>      <td valign="top">在必要时强制指定refmap的混淆类型。总是为<code>false</code>。</td>    </tr>    <tr>      <td valign="top"><code>mixin.env.disableRefMap</code></td>      <td valign="top">在必要时禁用refmap。    </td></tr>    <tr>      <td valign="top"><code>mixin.env.remapRefMap</code></td>      <td valign="top">你可能希望在运行时重新映射现有的refmap，而不是禁用refmap。这可以通过设置此属性，并为<code>mixin.env.refMapRemappingFile</code>和<code>mixin.env.refMapRemappingEnv</code>属性设置值实现。不过，如果通过<code>GradleStart</code>启动，则可以忽略这些属性（如果通过GradleStart加载，此属性也会自动启用）。</td>    </tr>    <tr>      <td valign="top"><code>mixin.env.refMapRemappingFile</code></td>      <td valign="top">如果启用<tt>mixin.env.remapRefMap</tt>，则可以使用此设置覆盖从文件中读取的SRG文件名。映射的源类型必须为<code>searge</code>且目标类型必须与当前的开发环境相匹配。 如果源类型不是<code>searge</code>，那么<code>mixin.env.refMapRemappingEnv</code>应设置为正确的源环境类型。</td>    </tr>    <tr>      <td valign="top"><code>mixin.env.refMapRemappingEnv</code></td>      <td valign="top">使用<code>mixin.env.refMapRemappingFile</code>时，此设置将覆盖默认源环境（searge）。但是请注意，指定的环境类型必须存在于原始refmap中。</td>    </tr>    <tr>      <td valign="top"><code>mixin.env.ignoreRequired</code></td>      <td valign="top">全局忽略所有配置的<code>required</code>属性。</td>    </tr>    <tr>      <td valign="top"><code>mixin.env.compatLevel</code></td>      <td valign="top">操作时的默认兼容性级别。</td>    </tr>    <tr>      <td valign="top"><code>mixin.env.shiftByViolation</code></td>      <td valign="top">在Mixin中超过<a href="http://jenkins.liteloader.com/job/Mixin/javadoc/org/spongepowered/asm/mixin/injection/At.html#by--">At.by</a>所定义的最大值时的行为。当前行为是<code>warn</code>. 在Mixin的更高版本中，这可能会升级为<code>error</code>.        <p>此选项的可用值包括：</p>        <dl>          <dt>ignore</dt>          <dd>Pre-0.7行为，遇到违规行为时不采取任何操作</dd>          <dt>warn</dt>          <dd>当前行为，针对违规行为会发出一条<tt>WARN</tt>级别的消息</dd>          <dt>error</dt>          <dd>违规行为会抛出异常</dd>        </dl>      </td>    </tr>    <tr>      <td valign="top"><code>mixin.initialiserInjectionMode</code></td>      <td valign="top">初始化注入的行为，当前支持的选项有<code>default</code>和<code>safe</code>。</td>    </tr>  </tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Mixin-Java-System-Properties&quot;&gt;Mixin Java System Properties&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>介绍PlantUML</title>
    <link href="https://mouse0w0.github.io/2020/06/25/Introduction-to-PlantUML/"/>
    <id>https://mouse0w0.github.io/2020/06/25/Introduction-to-PlantUML/</id>
    <published>2020-06-25T13:30:00.000Z</published>
    <updated>2025-05-20T11:48:56.964Z</updated>
    
    <content type="html"><![CDATA[<p>为了描述项目的编码需求，常常需要使用一些辅助制图工具，UML图就是一个不错的选择。在经过不断地试用和实践过程中，最终决定使用PlantUML。PlantUML是一个可以使用简单的语法描述UML图的开源工具，也可以简单有效的定制UML图的样式。</p><p>PlantUML在VSCode，IntelliJ Idea，Eclipse等多款软件中均有插件支持，下图仅演示如何安装VSCode的PlantUML扩展。</p><p><img src="/2020/06/25/Introduction-to-PlantUML/vscode_extension.png" alt="安装 PlantUML 扩展"></p><p>然后，要使用PlantUML的全部功能，还需要安装<strong>Graphviz</strong>。Graphviz是一个开源的图形可视化软件。下载地址：<a href="http://www.graphviz.org/download/">http://www.graphviz.org/download/</a></p><p>安装完毕后就可以在VSCode中编写你想要的UML类图了。</p><p><code>example.puml</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Bob-&gt;Alice : hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/25/Introduction-to-PlantUML/example.png" alt="PlantUML 示例"></p><blockquote><p>注：按快捷键<code>Alt+D</code>即可预览PlantUML结果，右键菜单中有更多功能可供选择。</p></blockquote><p>关于PlantUML图的语法，在此不做赘述，请前往官网查看相关教程：<a href="https://plantuml.com/zh/">PlantUML 中文官网</a></p><p>PlantUML的默认配色不一定很适合所有人使用，有些人更喜欢简洁一些的主题，可以在<code>@startuml</code>后添加<code>skinparam monochrome true</code>参数。</p><p><code>example.puml</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam monochrome true</span><br><span class="line">Bob-&gt;Alice : hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/25/Introduction-to-PlantUML/monochrome.png" alt="Monochrome 主题"></p><p>有的人更喜欢暗色主题，可以在<code>@startuml</code>后添加<code>skinparam monochrome reverse</code>参数使用暗色主题。</p><p><code>example.puml</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam monochrome reverse</span><br><span class="line">Bob-&gt;Alice : hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/25/Introduction-to-PlantUML/reverse_monochrome.png" alt="Monochrome 反转主题"></p><p>以上就是PlantUML提供的一些主题，如有需要可以自行阅读PlantUML的<a href="http://plantuml.com/zh/guide">用户指南</a>，通过<code>skinparam</code>修改样式。</p><p>再推荐一个非官方主题，有需要的可自行取用：<a href="https://github.com/xuanye/plantuml-style-c4">https://github.com/xuanye/plantuml-style-c4</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了描述项目的编码需求，常常需要使用一些辅助制图工具，UML图就是一个不错的选择。在经过不断地试用和实践过程中，最终决定使用PlantUML。PlantUML是一个可以使用简单的语法描述UML图的开源工具，也可以简单有效的定制UML图的样式。&lt;/p&gt;
&lt;p&gt;PlantUML</summary>
      
    
    
    
    
    <category term="Tool" scheme="https://mouse0w0.github.io/tags/Tool/"/>
    
    <category term="Design Pattern" scheme="https://mouse0w0.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Mixin参考——注入点参考</title>
    <link href="https://mouse0w0.github.io/2020/03/24/Mixin-Reference-Injection-Point-Reference/"/>
    <id>https://mouse0w0.github.io/2020/03/24/Mixin-Reference-Injection-Point-Reference/</id>
    <published>2020-03-24T06:03:15.000Z</published>
    <updated>2025-05-20T11:48:56.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Injection-Point-Reference">Injection Point Reference</a></p></blockquote><h3 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h3><table width="100%">    <tr><th>简写名</th><th>全名</th></tr>    <tr><td><a href="#head">HEAD</a></td><td>org.spongepowered.asm.mixin.injection.points.MethodHead</td></tr>    <tr><td><a href="#return">RETURN</a></td><td>org.spongepowered.asm.mixin.injection.points.BeforeReturn</td></tr>    <tr><td><a href="#tail">TAIL</a></td><td>org.spongepowered.asm.mixin.injection.points.BeforeFinalReturn</td></tr>    <tr><td><a href="#invoke">INVOKE</a></td><td>org.spongepowered.asm.mixin.injection.points.BeforeInvoke</td></tr>    <tr><td><a href="#invokestring">INVOKE_STRING</a></td><td>org.spongepowered.asm.mixin.injection.points.BeforeStringInvoke</td></tr>    <tr><td><a href="#invokeassign">INVOKE_ASSIGN</a></td><td>org.spongepowered.asm.mixin.injection.points.AfterInvoke</td></tr>    <tr><td><a href="#field">FIELD</a></td><td>org.spongepowered.asm.mixin.injection.points.BeforeFieldAccess</td></tr>    <tr><td><a href="#new">NEW</a></td><td>org.spongepowered.asm.mixin.injection.points.BeforeNew</td></tr>    <tr><td><a href="#constant">CONSTANT</a></td><td>org.spongepowered.asm.mixin.injection.points.BeforeConstant</td></tr></table><p><a name="head"></a></p><h2 id="在方法起始"><a href="#在方法起始" class="headerlink" title="在方法起始"></a>在方法起始</h2><blockquote><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>HEAD</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.MethodHead</tt></td></tr><tr><td><b>选项</b></td><td><i>无</i></td></tr><tr><td><b>参数</b></td><td><i>无</i></td></tr></table><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>此注入点始终返回候选列表中的第一条指令。在方法中选择时，始终是方法中的第一条指令；在指令片段（slice）中选择时，始终是指令片段中的第一条指令。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>此注入点保证只选择一条指令。</p></blockquote><hr><p><a name="return"></a></p><h2 id="在返回之前"><a href="#在返回之前" class="headerlink" title="在返回之前"></a>在返回之前</h2><blockquote><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>RETURN</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.BeforeReturn</tt></td></tr><tr><td><b>选项</b></td><td><dl><dt>ordinal</dt><dd>要选中的<tt>RETURN</tt>指令的序号（从<tt>0</tt>开始索引）</dd></dl></td></tr><tr><td><b>参数</b></td><td><i>无</i></td></tr></table><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>此注入点选择目标指令列表中的<tt>RETURN</tt>（返回）操作符。如果未指定<tt>ordinal</tt>（序号），则选择所有<tt>RETURN</tt>指令。</p><table><thead><tr><th>序号</th><th>检索范围</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td>省略的</td><td>方法</td><td>1个或更多指令</td><td>方法保证至少有1个<tt>RETURN</tt></td></tr><tr><td>指定的</td><td>方法</td><td>0或1个指令</td><td>与<tt>ordinal</tt>匹配的<tt>RETURN</tt>可能不存在</td></tr><tr><td>省略的</td><td>指令片段</td><td>0个或更多指令</td><td>匹配指令片段中的所有<tt>RETURN</tt>，其中也可能不包含任何<tt>RETURN</tt></td></tr><tr><td>指定的</td><td>指令片段</td><td>0或1个指令</td><td>匹配指令片段中的一个<tt>RETURN</tt>，其中也可能不包含期望的指令</td></tr></tbody></table><h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><p>这是<tt>&#64;Inject</tt>注入器注入构造函数时唯一允许使用的注入点。</p><p>当与<a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Callback-Injectors#5-targets-with-non-void-return-types">可取消的非空注入</a>结合使用时，此注入点将使返回类型在<tt>CallbackInfoReturnable</tt>中通过<tt>getReturnType()</tt>方法可用。</p></blockquote><hr><p><a name="tail"></a></p><h2 id="在最终返回之前"><a href="#在最终返回之前" class="headerlink" title="在最终返回之前"></a>在最终返回之前</h2><blockquote><h3 id="概览-2"><a href="#概览-2" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>TAIL</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.BeforeFinalReturn</tt></td></tr><tr><td><b>选项</b></td><td><i>无</i></td></tr><tr><td><b>参数</b></td><td><i>无</i></td></tr></table><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>此注入点返回目标方法中最后一个<code>RETURN</code>操作符。</p><h3 id="注释-2"><a href="#注释-2" class="headerlink" title="注释"></a>注释</h3><p>请注意，最后一个“RETURN”操作符可能与原Java源代码中方法的概念上的“最后”不对应，因为条件表达式可能导致编译得到的字节码与原Java源代码的顺序有显著差异。</p></blockquote><hr><p><a name="invoke"></a></p><h2 id="在调用之前"><a href="#在调用之前" class="headerlink" title="在调用之前"></a>在调用之前</h2><blockquote><h3 id="概览-3"><a href="#概览-3" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>INVOKE</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.BeforeInvoke</tt></td></tr><tr><td><b>选项</b></td><td><dl><dt>target</dt><dd>被调用的目标，如果被重映射，则必须写上全名</dd><dt>ordinal</dt><dd>要选中的已匹配的调用的索引序号（如果忽略该项，则全选）</dd></dl></td></tr><tr><td><b>参数</b></td><td><dl><dt><tt>boolean</tt> log</dt><dd>当注入器扫描方法时，在控制台中生成详细的输出，这对诊断不正确的行为或以意外方式注入的注入器非常有帮助</dd></dl></td></tr></table><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>此注入点在目标指令列表中搜索<em>invoke</em>指令，并返回与条件匹配的指令。<code>target</code>应该是一个可解析的<a href="http://jenkins.liteloader.com/job/Mixin/javadoc/index.html?org/spongepowered/asm/mixin/injection/struct/MemberInfo.html">MemberInfo</a>，它指定要搜索的调用（省略<code>target</code>将返回目标中的所有调用指令。序号指定要选择的调用的索引，如果省略，则返回所有匹配的调用。</p><h3 id="注释-3"><a href="#注释-3" class="headerlink" title="注释"></a>注释</h3><p><code>ordinal</code>值是<em>在与<code>target</code>匹配的指令</em>中选择，因此如果目标方法中有4个调用指令，但只有2个与<code>target</code>中指定的值匹配，那么给定<code>ordinal=1</code>将选择与<code>target</code>匹配的第二个指令，而不是方法中的第二个调用。换句话说，<code>target</code>总应用在<code>ordinal</code>前。</p></blockquote><hr><p><a name="invokestring"></a></p><h2 id="在仅有一字符串参数的Void返回值方法调用之前"><a href="#在仅有一字符串参数的Void返回值方法调用之前" class="headerlink" title="在仅有一字符串参数的Void返回值方法调用之前"></a>在仅有一字符串参数的Void返回值方法调用之前</h2><blockquote><h3 id="概览-4"><a href="#概览-4" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>INVOKE_STRING</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.BeforeStringInvoke</tt></td></tr><tr><td><b>选项</b></td><td><dl><dt>target</dt><dd>被调用的目标，如果被重映射，则必须写上全名</dd><dt>ordinal</dt><dd>要选中的已匹配的调用的索引序号（如果忽略该项，则全选）</dd></dl></td></tr><tr><td><b>参数</b></td><td><dl><dt><tt>string</tt> ldc</dt><dd>要匹配的常量值，请参见描述</dd><dt><tt>boolean</tt> log</dt><dd>当注入器扫描方法时，在控制台中生成详细的输出，这对诊断不正确的行为或以意外方式注入的注入器非常有帮助</dd></dl></td></tr></table><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>如同<a href="#invoke">BeforeInvoke</a>，此注入点在目标指令列表中搜素<em>invoke</em>指令，并返回与条件匹配的指令。此特化版本只匹配接受单个<code>String</code>并返回<code>void</code>的方法，字符串本身必须是文本字符串，并作为查询过程的一部分进行匹配。</p><p>此查询的主要目的是特定匹配<code>Profiler::startSection</code>的调用和只接受文本字符串的类似方法。</p><p>应使用名为<code>ldc</code>的参数指定要匹配的字符串常量。</p><h3 id="注释-4"><a href="#注释-4" class="headerlink" title="注释"></a>注释</h3><p>此查询只能用于匹配参数作为字符串文本传递的调用。</p><p>关于<code>target</code>与<code>ordinal</code>的应用顺序，请参见<a href="#invoke">BeforeInvoke</a>中的注释。</p></blockquote><hr><p><a name="invokeassign"></a></p><h2 id="在调用之后"><a href="#在调用之后" class="headerlink" title="在调用之后"></a>在调用之后</h2><blockquote><h3 id="概览-5"><a href="#概览-5" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>INVOKE_ASSIGN</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.AfterInvoke</tt></td></tr><tr><td><b>选项</b></td><td><dl><dt>target</dt><dd>被调用的目标，必须是非void返回类型，如果重映射，则必须写上全名</dd><dt>ordinal</dt><dd>要选中的已匹配的调用的索引序号（如果忽略该项，则全选）</dd></dl></td></tr><tr><td><b>参数</b></td><td><dl><dt><tt>boolean</tt> log</dt><dd>当注入器扫描方法时，在控制台中生成详细的输出，这对诊断不正确的行为或以意外方式注入的注入器非常有帮助</dd></dl></td></tr></table><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>与<code>BeforeInvoke</code>类似，此注入点在目标指令列表中搜索<em>invoke</em>指令，并返回符合条件的指令。但是目标指令<em>必须</em>返回一个值。如果满足此条件，则注入点立即返回调用之后的指令。如果调用紧接着是的<code>STORE</code>指令（例如，调用的结果储存在一个局部变量中），则注入点返回紧跟在<code>STORE</code>指令之后的指令。</p><h3 id="注释-5"><a href="#注释-5" class="headerlink" title="注释"></a>注释</h3><p>此注入点以与<code>BeforeInvoke</code>完全相同的方式选择候选指令，因此注意事项相同。</p></blockquote><hr><p><a name="field"></a></p><h2 id="在字段访问之前"><a href="#在字段访问之前" class="headerlink" title="在字段访问之前"></a>在字段访问之前</h2><blockquote><h3 id="概览-6"><a href="#概览-6" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>FIELD</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.BeforeFieldAccess</tt></td></tr><tr><td><b>选项</b></td><td><dl><dt>target</dt><dd>被访问的目标字段，如果重映射，则必须写上全名</dd><dt>opcode</dt><dd>要搜索的指令操作符（必须是<tt>GETSTATIC</tt>、<tt>PUTSTATIC</tt>、<tt>GETFIELD</tt>或<tt>PUTFIELD</tt>中的一个），如未指定则匹配所有字段访问</dd><dt>ordinal</dt><dd>要选择的字段访问的索引序号（如果省略，则全选）</dd></dl></td></tr><tr><td><b>参数</b></td><td><dl><dt><tt>boolean</tt> log</dt><dd>当注入器扫描方法时，在控制台中生成详细的输出，这对诊断不正确的行为或以意外方式注入的注入器非常有帮助</dd></dl></td></tr></table><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>此注入点在目标指令列表中搜索<code>GETFIELD</code>和<code>PUTFIELD</code>指令（及其静态的等效指令），并返回符合条件的指令。<code>target</code>应该是一个可解析的<a href="http://jenkins.liteloader.com/job/Mixin/javadoc/index.html?org/spongepowered/asm/mixin/injection/struct/MemberInfo.html">MemberInfo</a>，它指定要搜索的字段名（省略<code>target</code>将返回目标中相应类型的所有访问指令）。序号指定要选择的指令的索引，如果省略，则返回所有匹配的字段访问指令。</p><h3 id="注释-6"><a href="#注释-6" class="headerlink" title="注释"></a>注释</h3><p><code>ordinal</code>值是<em>在与<code>target</code>匹配的指令</em>中选择，因此如果目标方法中有4个字段访问指令，但只有2个与<code>target</code>中指定的值匹配，那么给定<code>ordinal=1</code>将选择与<code>target</code>匹配的第二个指令，而不是方法中的第二个字段访问。换句话说，<code>target</code>总应用在<code>ordinal</code>前。</p></blockquote><hr><p><a name="new"></a></p><h2 id="在调用对象构造方法之前"><a href="#在调用对象构造方法之前" class="headerlink" title="在调用对象构造方法之前"></a>在调用对象构造方法之前</h2><blockquote><h3 id="概览-7"><a href="#概览-7" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>NEW</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.BeforeNew</tt></td></tr><tr><td><b>选项</b></td><td><dl><dt>target</dt><dd>要重映射的构造方法描述符，改描述符必须<b>仅</b>包含<i>类名</i>或<i>类名和构造方法签名</i></dd><dt>ordinal</dt><dd>要选择的NEW操作符的索引序号（如果省略，则为全部）</dd></dl></td></tr><tr><td><b>参数</b></td><td><dl><dt><tt>String</tt> class</dt><dd>为后向兼容的替代<tt>target</tt>（ <tt>NEW</tt>最初仅支持此参数）。与<tt>target</tt>相同，仅能指定一个或另一个构造方法</dd></dl></td></tr></table><h3 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h3><p>此注入点在目标指令列表中搜索<code>NEW</code>指令，并返回符合条件的指令。如果指定了<code>target</code>，则只返回指定类型的<code>NEW</code>指令。如果<code>target</code>包含方法签名（该签名<strong>必须</strong>指定void（<code>V</code>)为返回类型），则只返回后跟有给定签名的<tt>INVOKESPECIAL(&lt;init&gt;)</tt>指令的<code>NEW</code>指令。注意，<strong>总是返回<code>NEW</code>指令，而不是<code>INVOKESPECIAL</code></strong>。</p><h3 id="注释-7"><a href="#注释-7" class="headerlink" title="注释"></a>注释</h3><p>注意，与其他注入点一样，<code>ordinal</code>适用于其他注入点参数的相同结论。因此，如果使用<code>target</code>标识<code>NEW</code>操作符的子集，<code>ordinal</code>将基于此子集进行选择，而不是在目标中的整个<code>NEW</code>操作符池中进行选择。在词语顺序中，<code>ordinal</code>始终<em>最后</em>应用。</p></blockquote><hr><p><a name="constant"></a></p><h2 id="在常量使用之前"><a href="#在常量使用之前" class="headerlink" title="在常量使用之前"></a>在常量使用之前</h2><blockquote><h3 id="概览-8"><a href="#概览-8" class="headerlink" title="概览"></a>概览</h3><table> <tr><td nowrap><b>简写名</b></td><td><tt>CONSTANT</tt></td></tr><tr><td><b>全名</b></td><td><tt>org.spongepowered.asm.mixin.injection.points.BeforeConstant</tt></td></tr><tr><td><b>选项</b></td><td><dl><dt>ordinal</dt><dd>要选择的NEW操作符的索引序号（如果省略，则为全部）</dd></dl></td></tr><tr><td><b>参数</b></td><td><dl><dt><tt>boolean</tt> nullValue</dt><dd>将此值设置为<tt>true</tt>以匹配方法体中的<tt>null</tt></dd><dt><tt>int</tt> intValue</dt><dd>将此值设置为要在方法体中匹配的整数。请注意，如果要匹配构成条件表达式中的一部分0值，可能还需要设置<tt>expandZeroConditions</tt>参数</dd><dt><tt>float</tt> floatValue</dt><dd>将此值设置为要在方法体中匹配的单精度浮点数</dd><dt><tt>long</tt> longValue</dt><dd>将此值设置为要在方法体中匹配的长整数</dd><dt><tt>double</tt> doubleValue</dt><dd>将此值设置为要在方法体中匹配的双精度浮点数</dd><dt><tt>String</tt> stringValue</dt><dd>将此值设置为要在方法体中匹配的文本</dd><dt><tt>String</tt> class</dt><dd>将此值设置为要在方法体中匹配的<tt>Class</tt></dd><dt><tt>boolean</tt> log</dt><dd>将此值设置为<tt>true</tt>以在应用此注入点查询时发出日志信息</dd><dt><tt>String</tt> expandZeroConditions</dt><dd>虽然大多数常量可以相对容易地位于编译后的方法中，但在条件表达式中使用0时存在特殊情况。例如：<blockquote><code>if (x >= 0)</code></blockquote>出现这种特殊情况是因为Java包含用于这种类型的比较的显式指令，因此编译后的代码可能更像这样：<blockquote><code>if (x.isGreaterThanOrEqualToZero())</code></blockquote>当然如果我们知道正在搜索的常量是比较表达式的一部分，那么我们可以显式地搜索<tt>isGreaterThanOrEqualToZero</tt>并将其转换为原始形式，以便像任何其他常量访问一样重定向它<br><br>如要启用此行为，可以基于要展开的表达式类型为次参数指定一个或多个值。因为Java编译器习惯将某些表达式编译为与其源代码对应的<i>逆</i>表达式（例如，编译<i>当大于某值时做某事</i>结构为<i>如果小于或等于某值则不做某事</i>）；指定特定的表达式类型也隐式包括逆表达式。<br><br>值得注意的是，其对序号的影响可能很难预测，因此应注意确保所选注入点与预期位置匹配<br><br>指定此选项具有以下效果：<br><br><ul><li>目标方法中的条件匹配操作符被识别为注入候选</li><li><tt>intValue</tt>为<tt>0</tt>是隐式的，不需要显式定义</li><li>但是，显式指定<tt>intValue</tt>为<tt>0</tt>将导致此选择器也与方法体重的显示<tt>0</tt>常量匹配</li></ul>要为该选项指定值，请用逗号或空格分隔<tt>条件值</tt>，例如：<blockquote><code>"expandZeroConditions=LESS_THAN_ZERO,GREATER_THAN_ZERO"</code></blockquote></dd></dl></td></tr></table><h3 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h3><p>此注入点在目标指令列表中搜索字面值（常量），并返回与条件相匹配的指令。请注意，所有鉴别参数都是互斥的，并且只应指定<em>一个</em>鉴别参数。指定多个鉴别参数将抛出异常。</p><h3 id="注释-8"><a href="#注释-8" class="headerlink" title="注释"></a>注释</h3><p>注意，与其他注入点一致，<code>ordinal</code>适用于注入点其他参数的总体结果。在词语顺序中，<code>ordinal</code>始终<em>最后</em>应用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Injection-Point-Reference&quot;&gt;Injection Point Reference&lt;/a&gt;&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>初试JNI</title>
    <link href="https://mouse0w0.github.io/2019/05/10/First-try-JNI/"/>
    <id>https://mouse0w0.github.io/2019/05/10/First-try-JNI/</id>
    <published>2019-05-10T07:00:38.000Z</published>
    <updated>2025-05-20T11:48:56.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：Java 11; IntelliJ IDEA 2019.1.1; Visual Studio 2019</p></blockquote><p><strong>第一步：编写Java类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LearnJNI</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">helloJNI</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;LearnJNI&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LearnJNI</span>().helloJNI();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：使用Java类生成C头文件</strong></p><p>在Java的编译输出目录下执行如下指令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -h . com.github.mouse0w0.learnjni.LearnJNI</span><br></pre></td></tr></table></figure></p><blockquote><p>在Java 10之前，生成头文件主要通过<code>javah</code>:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -classpath . -jni com.github.mouse0w0.learnjni.LearnJNI</span><br></pre></td></tr></table></figure></p></blockquote><p>结果如下图所示：</p><p><img src="/2019/05/10/First-try-JNI/1.png" alt="Javah指令执行结果"></p><p><strong>第三步：使用Visual Studio创建C++项目</strong></p><p>在Visual Studio中选择C++空项目：</p><p><img src="/2019/05/10/First-try-JNI/2.png" alt="创建新项目"></p><p>配置好项目名称，任取即可：</p><p><img src="/2019/05/10/First-try-JNI/3.png" alt="配置新项目"></p><p>得到这样一个文件结构的项目：</p><p><img src="/2019/05/10/First-try-JNI/4.png" alt="文件层次结构"></p><p>创建头文件与CPP文件，并将我们使用javah生成的头文件的内容复制到创建的头文件中：</p><p><img src="/2019/05/10/First-try-JNI/5.png" alt="头文件"></p><p>我们可以看到有很多错误。不过接下来将配置我们的C++项目。</p><p><strong>第四步：配置C++项目</strong></p><p>右键解决方案，打开属性：</p><p><img src="/2019/05/10/First-try-JNI/6.png" alt="解决方案属性"></p><p>选中<code>配置属性&gt;配置</code>，设置配置为<code>Release</code>，平台为<code>x64</code>：</p><p><img src="/2019/05/10/First-try-JNI/7.png" alt="设置配置属性"></p><p>右键<code>LearnJNI</code>项目，打开属性：</p><p><img src="/2019/05/10/First-try-JNI/8.png" alt="项目属性"></p><p>选中<code>配置属性&gt;常规</code>，设置<code>项目默认值&gt;配置类型</code>为<code>动态库(.dll)</code>：</p><p><img src="/2019/05/10/First-try-JNI/9.png" alt="设置配置类型"></p><p>选中<code>配置属性&gt;VC++ 目录</code>，点击<code>常规&gt;包含目录</code>的<code>&lt;编辑...&gt;</code>：</p><p><img src="/2019/05/10/First-try-JNI/10.png" alt="编辑包含目录"></p><p>点击红框内按钮，添加JDK路径下的<code>include</code>文件夹和<code>include\win32</code>文件夹：</p><p><img src="/2019/05/10/First-try-JNI/11.png" alt="包含目录"></p><p><strong>第五步：实现C++代码</strong></p><p>在CPP文件中编写如下代码，输出<code>Hello World</code>：</p><p><img src="/2019/05/10/First-try-JNI/12.png" alt="CPP代码"></p><p><strong>第六步：编译C++代码为DLL</strong></p><p>点击Visual Studio上方的菜单栏中的<code>生成&gt;生成 LearnJNI</code>生成项目：</p><p><img src="/2019/05/10/First-try-JNI/13.png" alt="生成DLL"></p><p>最终得到如下输出，输出DLL的路径在下图红框内：</p><p><img src="/2019/05/10/First-try-JNI/14.png" alt="生成DLL输出"></p><p><strong>第七步：配置Java运行</strong></p><p>将输出的DLL置于Java项目下的适宜文件夹：</p><p><img src="/2019/05/10/First-try-JNI/15.png" alt="Native文件夹"></p><p>在IDEA的启动配置中增加JVM参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.library.path=D:\Workspace\JavaProjects\LearnJNI\native</span><br></pre></td></tr></table></figure><p><img src="/2019/05/10/First-try-JNI/16.png" alt="JVM参数"></p><p>运行启动配置，得到<code>Hello World</code>的输出：</p><p><img src="/2019/05/10/First-try-JNI/17.png" alt="Hello World"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本篇教程中所讲解的JNI和C/C++项目的开发和使用方法还很幼稚，读者可就情况进行进一步的学习和改进。如使用头文件自动生成工具，使用CMake配置跨平台的C/C++项目编译。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/w3cnote/jni-getting-started-tutorials.html">JNI 入门教程 | 菜鸟教程</a></p><p><a href="https://blog.csdn.net/l460133921/article/details/73824985">Visual Studio中开发Jni dll库</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发环境：Java 11; IntelliJ IDEA 2019.1.1; Visual Studio 2019&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第一步：编写Java类&lt;/strong&gt;&lt;/p&gt;
&lt;figure class</summary>
      
    
    
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="C/C++" scheme="https://mouse0w0.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>你好Gitalk</title>
    <link href="https://mouse0w0.github.io/2019/01/30/Hello-Gitalk/"/>
    <id>https://mouse0w0.github.io/2019/01/30/Hello-Gitalk/</id>
    <published>2019-01-30T17:35:25.000Z</published>
    <updated>2025-05-20T11:48:56.940Z</updated>
    
    <content type="html"><![CDATA[<p>现在，本博客正式列装了评论系统，欢迎各位讨论哦！</p><p>Gitalk仓库地址：<a href="https://github.com/gitalk/gitalk">https://github.com/gitalk/gitalk</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在，本博客正式列装了评论系统，欢迎各位讨论哦！&lt;/p&gt;
&lt;p&gt;Gitalk仓库地址：&lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;https://github.com/gitalk/gitalk&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Tool" scheme="https://mouse0w0.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Java本地接口（JNI）</title>
    <link href="https://mouse0w0.github.io/2019/01/30/How-to-use-JNI/"/>
    <id>https://mouse0w0.github.io/2019/01/30/How-to-use-JNI/</id>
    <published>2019-01-30T09:04:21.000Z</published>
    <updated>2025-05-20T11:48:56.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：</p><p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html">Java Native Interface Specification (Java 11)</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html">Java Programming Tutorial Java Native Interface (JNI)</a></p><p><a href="https://www.jianshu.com/p/f6e3dd8edb13">JNI 学习笔记</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html&quot;&gt;Java Native Interface Specificati</summary>
      
    
    
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="C/C++" scheme="https://mouse0w0.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>高级Mixin用法——回调注入器</title>
    <link href="https://mouse0w0.github.io/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/"/>
    <id>https://mouse0w0.github.io/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/</id>
    <published>2018-12-05T04:51:16.000Z</published>
    <updated>2025-05-20T11:48:56.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Callback-Injectors">Advanced Mixin Usage Callback Injectors</a></p></blockquote><p>如果你还没有读过<strong>介绍系列</strong>的话，现在回头吧，因为<em>这里是龙潭虎穴</em>……</p><p>还不走？好吧，我们开始吧。</p><h3 id="1-从以太诞生的代码——了解注入器"><a href="#1-从以太诞生的代码——了解注入器" class="headerlink" title="1. 从以太诞生的代码——了解注入器"></a>1. 从以太诞生的代码——了解注入器</h3><p>如果你已经读过了介绍系列，你就知道如何使用Mixin处理器将你提供的代码合并到<strong>目标类</strong>中。实际上，即使有了如<em>内部代理</em>那样更复杂的功能，最终得到的目标类的代码也只是原始字节码和你提供的新代码的混合。</p><p><strong>回调注入器（Callback Injector）</strong>是你将学会的第一个不同以往的Mixin技术：有了<strong>回调注入器</strong>，可以让Mixin处理器为我们<strong>生成新代码</strong>。</p><p><strong>回调注入器</strong>由两部分组成：</p><ul><li>一个<strong>常规Mixin方法</strong>即一个<strong>处理方法（Handler Method）</strong>，该方法通过含有一些自定义代码的Mixin添加到目标类中。</li><li>一个<strong>注入点（Injection Point）</strong>定义 - 这是一个注解以告诉Mixin处理器在何处创建在<strong>现有方法</strong>（或称为<strong>目标方法</strong>）内的指令，该方法将<strong>调用我们的处理方法</strong>。</li></ul><p>在我们探讨更多细节之前，来介绍一下我们的学习样例。下图展示了一个非常简单的类<code>Flard</code>中的一些代码：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_00.png" alt></p><p><code>Flard</code>类包含：</p><ul><li>一个<code>protected</code>字段<code>position</code></li><li>一个<code>public</code>方法<code>setPos</code></li><li>一个<code>protected</code>方法<code>update</code></li></ul><p><code>Flard</code>的内部行为是每当属性发生改变时，属性的设置器总是在返回之前调用<code>update()</code>方法。<code>update</code>方法在属性改变时将对象状态发送到服务器。</p><blockquote><p>注意，即使该方法返回<code>void</code>，我仍然在代码中囊括了一个显式的<code>return</code>。原因是——在字节码中——没有所谓的<em>隐式</em>返回，在方法的字节码中总是有一个<code>RETURN</code>操作符。在我们之后考虑<em>注入点</em>时，这是一个重要的事情。</p></blockquote><p>让我们看看从一些外部代码调用<code>setPos</code>设置器的执行流程：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_01.png" alt></p><p>这里并没有发生什么特别的事情，箭头精确地指示了我们期望给定代码发生的事情。</p><h4 id="1-1-概括——你已经知道的东西"><a href="#1-1-概括——你已经知道的东西" class="headerlink" title="1.1 概括——你已经知道的东西"></a>1.1 概括——你已经知道的东西</h4><p>到目前为止很无聊。假设我们想进入<code>update()</code>操作，我们想要添加一些自定义逻辑——也许通知一些观察者类——在调用<code>update()</code>时。我们已知可以通过用<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Overwriting-Methods">修改后的版本重写它</a>甚至使用 <em><a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Overwriting-Methods#2-intrinsic-proxy-methods">内部代理</a>替代</em>以保持原始方法。然而，我们也知道重写在可维护性和互操作性方法有<strong>很多</strong><a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Overwriting-Methods#12-with-great-power-comes-great-possibility-to-screw-things-up">缺点</a>。</p><p>那么，如何在不重写的情况下向方法添加自定义逻辑呢？</p><p>答案是：<em>告诉方法调用我们的自定义代码！</em></p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/invoke.png" alt></p><h4 id="1-2-你要调用谁？onUpdate！"><a href="#1-2-你要调用谁？onUpdate！" class="headerlink" title="1.2 你要调用谁？onUpdate！"></a>1.2 你要调用谁？onUpdate！</h4><p>在我们了解注入器的旅程中，第一步实际上也是我们已知的：将<em>新</em>的方法添加到目标类中。我们将注入的方法称为<strong>处理方法</strong>，并且通常我们使用前缀“<code>on</code>”标记处理方法，这与许多框架中使用的事件接受器的命名约定非常相似。</p><p>我们将本例中这个新的<strong>处理</strong>方法命名为<code>onUpdate</code>，因为我们将挂钩到<code>update</code>方法。</p><blockquote><p>使用紧随目标方法名称的<code>on</code>术语有助于Mixin代码的可读性，因为任何阅读Mixin代码的人都可以在不必检查注入器定义的情况下了解该方法所含的内容。</p></blockquote><p>因此，假设我们的第一步是使用Mixin将新的<strong>处理</strong>方法<code>onUpdate</code>添加到目标类中。在本例中，<strong>处理</strong>方法简单地对某个假想名为<code>Observer</code>的单例观察者对象调用<code>foo</code>：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_02.png" alt></p><p>好，一切都很好，但是我们的新方法基本上只是呆在那里，除此之外什么都不做，所以让我们看看我们如何做注入器的实际<em>注入</em>部分：</p><h4 id="1-3-头（HEAD）-肩膀-膝盖-返回（RETURN）-膝盖-返回（RETURN）"><a href="#1-3-头（HEAD）-肩膀-膝盖-返回（RETURN）-膝盖-返回（RETURN）" class="headerlink" title="1.3 头（HEAD）, 肩膀, 膝盖, 返回（RETURN）, 膝盖, 返回（RETURN）!"></a>1.3 头（HEAD）, 肩膀, 膝盖, 返回（RETURN）, 膝盖, 返回（RETURN）!</h4><p>在开始之前，我们首先要做的是识别目标方法的各部分。让我们用记号标记<code>update()</code>方法，这些记号标明了我们能够容易识别的一些区域：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_03.png" alt></p><p>记号标明了该方法的各部分剖析：</p><ul><li><strong>HEAD</strong>表示方法体中的<em>第一个操作符之前</em>的点，即方法的“头”。</li><li><strong>RETURN</strong>表示方法中的<em><code>RETURN</code>操作符之前</em>的点。</li></ul><p>在一个方法中，我们还可以标记出其他要点，但是现在我们仅重点关注这些简单的标记，在注入器术语中，这些方法中的位置被称为<strong>注入点</strong>。</p><h4 id="1-4-嘿，我刚刚混入，这太疯狂了，但我是一个方法，也许该调用我？"><a href="#1-4-嘿，我刚刚混入，这太疯狂了，但我是一个方法，也许该调用我？" class="headerlink" title="1.4 嘿，我刚刚混入，这太疯狂了，但我是一个方法，也许该调用我？"></a>1.4 嘿，我刚刚混入，这太疯狂了，但我是一个方法，也许该调用我？</h4><p>现在我们准备链接这些点。首先我们将用注入器声明来修饰我们的<code>onUpdate</code>处理方法：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_04.png" alt></p><p>如你所见，<code>@Inject</code>注解需要两条信息：要注入的<strong>方法</strong>和要注入的<strong>点</strong>。在代码中看起来是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Inject(method = &quot;update&quot;, at = @At(&quot;HEAD&quot;))</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    Observer.instance.foo(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Mixin处理器应用Mixin方法时，它看到<code>@Inject</code>注解并在<strong>目标</strong>方法中生成调用<strong>处理</strong>方法的代码：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_05.png" alt></p><p>我们的<strong>处理</strong>函数的注入回调以紫色显示。与重写不同，<strong>目标</strong>方法的原始行为是不受影响的，我们的<strong>处理</strong>方法只是在方法开始时接收回调。</p><p>最终，使用注入器的步骤总结如下：</p><ol><li>识别<strong>注入点</strong>（接下来有更多关于此的介绍）。</li><li>编写你的<strong>处理方法</strong>。</li><li>用一个<code>@Inject</code>注解来修饰处理方法以创建注入关系。</li></ol><p>现在我们理解了基础知识，我们已经准备好深入研究这个问题。</p><h3 id="2-构建处理方法"><a href="#2-构建处理方法" class="headerlink" title="2. 构建处理方法"></a>2. 构建处理方法</h3><p>为了引入注入器的概念而简化了上述介绍。实际上，所有注入器的<strong>处理方法</strong>必须在其参数中接收<code>CallbackInfo</code>对象。该对象由回调生成，并作为句柄，在编写<em>可取消注入器</em>时可使用该句柄（更多信息见下文）。</p><p>我们此前的示例代码实际上是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Inject(method = &quot;update&quot;, at = @At(&quot;HEAD&quot;))</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUpdate</span><span class="params">(CallbackInfo ci)</span> &#123;</span><br><span class="line">    Observer.instance.foo(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>上面的示例也得到了简化，因为目标方法不接收参数并返回<code>void</code>。</p></blockquote><h4 id="2-1-获取目标参数"><a href="#2-1-获取目标参数" class="headerlink" title="2.1 获取目标参数"></a>2.1 获取目标参数</h4><p>当注入到有参数的<strong>目标方法</strong>时，<strong>目标方法</strong>的参数也可以作为注入的一部分传递给<strong>处理方法</strong>。让我们看到上例中的<code>setPos(int, int)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个目标方法，setPos</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    <span class="built_in">this</span>.position = p;</span><br><span class="line">    <span class="built_in">this</span>.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要为这个方法创建一个注入器，我们可以选择在我们的<strong>处理</strong>方法中使用两个整型参数（<code>x</code>和<code>y</code>）。我们可以简单地将它们添加到我们的<strong>处理方法</strong>的签名中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理方法，onSetPos，注意两个int变量x和y出现在CallbackInfo之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inject(method = &quot;setPos&quot;, at = @At(&quot;HEAD&quot;))</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onSetPos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, CallbackInfo ci)</span> &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;Position is being set to (%d, %d)\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们仍需包含<code>CallbackInfo</code>参数。注入<code>setPos</code>的代码先现在看起来是这样的，注意调用在调用<strong>处理</strong>方法<code>onSetPos</code>时传递了参数<code>x</code>和<code>y</code>：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_06.png" alt></p><p>方法参数和CallbackInfo一同为注入提供<strong>环境（Context）</strong>，并允许你相应地更改处理器的行为。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理方法，onSetPos</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inject(method = &quot;setPos&quot;, at = @At(&quot;HEAD&quot;))</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onSetPos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, CallbackInfo ci)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查如果设置位置到原点</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleOriginPosition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-可取消注入"><a href="#3-可取消注入" class="headerlink" title="3. 可取消注入"></a>3. 可取消注入</h3><p>到目前为止，我们的注入根本没有改变目标方法的结构，它只是调用我们的处理函数，使它执行我们需要的任何操作，而不改变目标方法。<strong>可取消注入</strong>允许我们创建可以提前从目标方法<em>return</em>的注入。</p><p>从上面的<code>setPos</code>示例将注入的代码可以看出，注入的代码包括创建一个新的<code>CallbackInfo</code>实例，然后调用<strong>处理方法</strong>。但是，现在我们将向<code>@Inject</code>注解中的注入器声明添加<code>cancellable</code>标识。我们还将为处理方法体添加一些逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可取消注入，注意我们在注入器注解中将&quot;cancellable&quot;标识设置为&quot;true&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inject(method = &quot;setPos&quot;, at = @At(&quot;HEAD&quot;), cancellable = true)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onSetPos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, CallbackInfo ci)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查位置是否设置到原点，并执行自定义逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 一些自定义逻辑</span></span><br><span class="line">        <span class="built_in">this</span>.position = Point.ORIGIN;</span><br><span class="line">        <span class="built_in">this</span>.handleOriginPosition();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 就像原方法一样调用update()</span></span><br><span class="line">        <span class="built_in">this</span>.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将回调标记为已取消</span></span><br><span class="line">        ci.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时正常执行，不执行自定义处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<strong>处理方法</strong>检查位置是否设置为<code>(0, 0)</code>，并执行一些自定义逻辑，将回调标记为<strong>已取消</strong>，以使目标方法（<code>setPos</code>）在<strong>注入之后立刻返回</strong>。我们可以看到目标方法是如何处理注入到<code>setPos</code>的代码，看起来就像这样：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_07.png" alt></p><p>如你所见，将注入标记为可取消的，会导致Mixin处理器注入代码时会检查<code>CallbackInfo</code>是否被标记为已取消，如果是，则立刻返回。</p><blockquote><p>注意：在<em>不可取消</em>的<code>CallbackInfo</code>上调用<code>cancel()</code>将引发异常！</p></blockquote><p>对于我们<strong>在方法<code>HEAD</code>处，并且有条件地返回的注入</strong>，被称为<strong>短路注入（Short Circuit Injection）</strong>，这对于那些本来是需要<code>@Overwrite</code>的东西是非常好的替代方案。也可以写一个总是取消的短路注入，这种类型的注入器被称为<strong>永久短路注入（Permanent Short Circuit）</strong>或<strong>阻断注入（RoadBlock Injection）</strong>。</p><blockquote><p>注意，大多数情况下，阻断注入最好是重写。其原因是因为它允许其他转换器对原始方法进行操作，而不会引起错误；还因为将注入的代码保持在单独的方法中，这使得在注入的代码中发生异常时，堆栈追踪更有用。</p></blockquote><h3 id="4-瞄准——注入点"><a href="#4-瞄准——注入点" class="headerlink" title="4. 瞄准——注入点"></a>4. 瞄准——注入点</h3><p>此前，我们已经遇到了两个不同的<strong>注入点</strong>：<code>HEAD</code>和<code>RETURN</code>，并且看到了第一个示例。在定义所有类型的注入器时，理解注入点是至关重要的，因为你选择的注入点类型将取决于你希望注入达成什么目的。</p><p><code>HEAD</code>和<code>RETURN</code>注入点是特殊的，因为它们是<em>保证成功的</em>唯一注入点，这是因为在一个方法中<em>总是</em>至少有一个RETURN操作符，并且总会自然有一个方法“头”。</p><h4 id="4-1-在草垛中寻找操作符"><a href="#4-1-在草垛中寻找操作符" class="headerlink" title="4.1 在草垛中寻找操作符"></a>4.1 在草垛中寻找操作符</h4><p>关于注入点，首先需要明白的是，它们本质上是<em>查询</em>目标方法运行字节码中一个<em>或更多</em>个与其标准匹配的操作符。没错：一个注入点可以匹配不止一次。</p><p>举一个例子，让我们思考一下<code>RETURN</code>注入点的含义。<code>RETURN</code>注入点的定义如下：</p><ul><li><code>RETURN</code>匹配目标方法中的<em>所有RETURN操作符</em>。</li></ul><p>Mixin处理器将始终在匹配的操作符<em>之前立刻</em>注入回调，因此使用<code>RETURN</code>将始终在方法返回之前立刻注入回调。</p><p>让我们看一个例子：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_08.png" alt></p><p>在本例中，我们修改了<code>setPos</code>方法，并在方法中添加了一些带有显式返回值的额外逻辑。除了方法结尾的<em>隐式</em>返回以外，这还意味着现在方法体中含有<em>两个</em>RETURN操作符。当我们标记方法中的注入点时，我们可以看到这映射在<code>RETURN</code>所标识的注入点中：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_09.png" alt></p><p>为了区分所标记的操作符，由注入点标识的每个操作符都以从零开始的数字标记，该操作符索引被称为<strong>序号（Ordinal）</strong>，并且是从零开始的索引。</p><p>假设我们想要编写一个只在第一个RETURN操作符上放置的回调注入器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject(method = &quot;setPos&quot;, at = @At(value = &quot;RETURN&quot;, ordinal = 0))</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResetPos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, CallbackInfo ci)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理方法的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>@At</code>中指定<code>ordinal</code>值意味着我们只在<em>第一个</em>RETURN操作符之前进行注入。</p><blockquote><p><strong>注意:</strong>你可能会问自己：<em>这个示例注入与仅注入<code>reset()</code>方法有什么区别？它会在同一个点被调用，对吧？</em></p><p>选择正确的注入器目标可能是极其主观的，并且很多时候将取决于你试图通过特定注入实现什么，以及其他因素，例如所讨论的对象的子类，以及范围中可用的变量。</p><p>例如，在上述发方法中，注入<code>reset()</code>会在同一点引发回调，但是如果<code>reset()</code>被子类重载了怎么办？<code>reset()</code>方法也不接收参数<code>x</code>和<code>y</code>的副本，这是我们可能需要的。另外，如果从代码中的其他点调用<code>reset()</code>方法会怎么样呢？所有这些事情都应该考虑。</p><p>选择合适的注入点在很大程度上取决于所讨论的类的结构（和层次结构）以及注入后打算做什么。在确定注入点是，应该考虑注入目标的使用及其性质的所有方面。</p></blockquote><h4 id="4-2-注入点的性质"><a href="#4-2-注入点的性质" class="headerlink" title="4.2 注入点的性质"></a>4.2 注入点的性质</h4><p>在进一步讨论之前，需要了解一些关于注入点的关键内容：</p><ul><li><p>除少数情况外，注入器将把其注入的代码置于<strong>注入点标识的操作符之前</strong>。这应该是很直观的，一些例子如下：</p><ul><li><code>RETURN</code>标识方法中的<code>RETURN</code>操作符，注入发生在方法返回之前。</li><li><code>HEAD</code>标识方法中的<em>第一个</em>操作符，注入发生在方法的开始处。</li><li><code>INVOKE</code>（参见下文）标识方法调用，注入发生在方法调用之前。</li></ul></li><li><p>由于它们是高效的查询，注入点<strong>可能不会返回结果</strong>。例如，假设在上述的示例中，我们指定<code>RETURN</code>作为查询，其<code>ordinal</code>值为<code>2</code>。由于在该方法中只有两个返回操作符，所以注入点将不匹配操作符。你可以使用约束指定可接受的上限和下限。</p></li><li><p>虽然对于一个<strong>给定的方法</strong>注入点是<strong>确定的</strong>，但是当注入<strong>一个变化的代码库</strong>时，这并不能消除维护负担。除了<code>HEAD</code>（它总是匹配相同的点），当目标代码库改变时，应该检查所有的注入点，尤其是那些使用<code>ordinal</code>偏移量或具有其他参数化设置的注入点，以确保它们始终正确。</p></li><li><p>定义更复杂的注入点（下面将详细介绍）是Mixin中少数几个必须<em>弄脏你的手</em>并查看<strong>目标方法</strong>的字节码的地方之一。这通常是必要的，所以你可以选择最适合你的注入操作符，一个好的反汇编器将在此为你提供巨大的帮助。</p></li></ul><h4 id="4-3-其他类型的注入点"><a href="#4-3-其他类型的注入点" class="headerlink" title="4.3 其他类型的注入点"></a>4.3 其他类型的注入点</h4><p>你可用的注入点中，除了<code>HEAD</code>和<code>RETURN</code>以外，还可以选择使用其他预定义的注入点：</p><table width="100%">    <tr>        <th>注入点</th>        <th>代码识别方式</th>    </tr>    <tr>        <td><tt>INVOKE</tt></td>        <td>查找方法调用并在其之前注入</td>    </tr>    <tr>        <td><tt>FIELD</tt></td>        <td>查找字段读写并在其之前注入</td>    </tr>    <tr>        <td><tt>NEW</tt></td>        <td>查找<tt>NEW</tt>操作符（对象创建）并在其之前注入</td>    </tr>    <tr>        <td><tt>JUMP</tt></td>        <td>查找跳转操作符（任何类型）并在其之前注入</td>    </tr>    <tr>        <td><tt>INVOKE_STRING</tt></td>        <td>查找方法调用，该方法接受单个<tt>String</tt>并返回<tt>void</tt>，或者说该方法接受常量字符串作为参数。这可以主要用于查找对<tt>Profiler.startSection(nameOfSection)</tt>的调用。</td>    </tr>    <tr>        <td><tt>INVOKE_ASSIGN</tt></td>        <td>查找方法调用，该方法调用后返回一个值，并在该值被分配给本地变量之后立刻注入。<b>注：这是唯一一个在注入点<em>之后</em>的注入</b></td>    </tr></table><p>更多细节请看<a href="https://github.com/SpongePowered/Mixin/wiki/Injection-Point-Reference">注入点参考</a></p><h3 id="5-具有非Void返回类型的目标方法"><a href="#5-具有非Void返回类型的目标方法" class="headerlink" title="5. 具有非Void返回类型的目标方法"></a>5. 具有非Void返回类型的目标方法</h3><p>到目前为止，我们仅考虑注入一个返回<code>void</code>的目标方法。当注入具有非<code>void</code>返回类型的方法中时，注入器<strong>处理方法</strong>将替代性地接收一个<code>CallbackInfoReturnable</code>。<code>CallbackInfoReturnable</code>不同于它的父类<code>CallbackInfo</code>：</p><ul><li><code>CallbackInfoReturnable</code>是泛型的，方法的返回类型是它的类型参数。</li><li>当取消一个具有返回类型的<code>cancellable</code>回调时，可以通过调用<code>setReturnValue</code>而不是<code>cancel</code>来指定从该方法返回的值。</li></ul><p>正如你所想的，当注入Getter，或当在<code>HEAD</code>注入使一个方法<strong>短路</strong>时，这是非常有用的。让我们来看一个返回值的示例方法：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_10.png" alt></p><p><code>getPos</code>方法是一个典型的<em>Getter</em>方法，因为它的方法体仅返回受保护的字段的值。让我们添加一个注入<code>HEAD</code>的Mixin，如果字段为<code>null</code>，则返回默认值：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_11.png" alt></p><p>注入器首先将我们的<strong>处理方法</strong>合并到目标类中，然后将代码注入到<strong>目标方法</strong>中以处理取消。</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_12.png" alt></p><p>注意注入的代码与此前展示的<code>void</code>类型的短路代码的区别。这次如果取消回调，注入器返回我们在<code>CallbackInfoReturnable</code>中设置的值。我们的Mixin代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject(method = &quot;getPos&quot;, at = @At(&quot;HEAD&quot;), cancellable = true)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onGetPos</span><span class="params">(CallbackInfoReturnable&lt;Point&gt; cir)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.position == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// setReturnValue 隐式 cancel() 回调</span></span><br><span class="line">        cir.setReturnValue(Point.ORIGIN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意，如果处理方法正常返回，则方法继续正常运行，就像可取消注入不调用cancel()的正常情况一样。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以想象，这种注入器非常强大，并且不限于注入<code>HEAD</code>，你可以使用任何你希望的注入点。然而，带使用可取消可返回注入时，会发生一些特殊情况：</p><p>你可能会想 <em>“但在这个非常简单的方法中，<code>HEAD</code>和<code>RETURN</code>的基本上意思是一样的，对吧？”</em></p><p>可以原谅你这样想，因为这似乎是逻辑推断的结果，然而在实际中，单个语句<code>return this.position</code>实际上包含两个操作：</p><ol><li>获取字段<code>position</code>的值。</li><li>返回这个值。</li></ol><p>这个值临时储存在方法的<em>参数堆栈</em>中，你可以将这些视为临时的、不可见的变量，这些变量在JVM操作值时储存这些值。从实际的角度来看，这意味着<code>HEAD</code>和<code>RETURN</code>在方法中实际上是位置分开的！</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_13.png" alt></p><p>由于我们知道，<code>RETURN</code>操作符必须返回一个值，因此我们知道，无论何时在<code>RETURN</code>注入，该值都可用于访问。注入处理器处理这种情况，并将返回值“捕获”并传递给处理方法的CallbackInfo中：</p><p><img src="/2018/12/05/Advanced-Mixin-Usage-Callback-Injectors/flard_14.png" alt></p><p>这种方法有很多好处：</p><ul><li>现在我们的注入器Key更松散地耦合到<strong>目标方法</strong>的实现中。换句话说，如果<strong>目标</strong>方法更改，我们的处理方法不需要知道更改，因为它只关心返回的值。</li><li>如果<strong>目标</strong>反复有多个<code>RETURN</code>操作符，则返回的值仍可被处理，而不需要额外的上下文。</li><li>它运行我们进行“观察者”注入，该注入仅<em>检查</em>返回的值，而不实际更改它或担心方法的实现。</li></ul><p>例如，让我们更改上述例子，用<code>RETURN</code>代替<code>HEAD</code>。我们关系的是让这个方法不返回<code>null</code>，所以我们的代码变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject(method = &quot;getPos&quot;, at = @At(&quot;RETURN&quot;), cancellable = true)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onGetPos</span><span class="params">(CallbackInfoReturnable&lt;Point&gt; cir)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查捕获的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (cir.getReturnValue() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为空，设置默认值为返回值</span></span><br><span class="line">        cir.setReturnValue(Point.ORIGIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-回调注入器特性"><a href="#6-回调注入器特性" class="headerlink" title="6. 回调注入器特性"></a>6. 回调注入器特性</h3><h4 id="6-1-多注入点"><a href="#6-1-多注入点" class="headerlink" title="6.1 多注入点"></a>6.1 多注入点</h4><p>应该注意的是，<code>@Inject</code>注解的<code>at</code>参数实际上是数组类型。这意味着可为单个注入器处理方法指定多个注入点。</p><h4 id="6-2-目标通配符"><a href="#6-2-目标通配符" class="headerlink" title="6.2 目标通配符"></a>6.2 目标通配符</h4><p>当为注入器指定目标<code>method</code>时，添加星号（<code>*</code>）的方法名称可指定Mixin处理器匹配所有具有指定名称的方法，不管它们的签名如何。这允许单个注入器以多个方法为目标。</p><p>使用这种语法会使捕获方法参数变得不可能，因为方法参数会因方法而异。然而，它使观察类型的注入变得简单。例如，思考下面的注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject(method = &quot;&lt;init&gt;*&quot;, at = @At(&quot;RETURN&quot;))</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onConstructed</span><span class="params">(CallbackInfo ci)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注入器向类中的所有构造方法注入回调。如果目标类具有多个重载的构造方法，并且你仅希望将其注入到所有构造方法中，那么这非常有用。</p><p>目标通配符可以与任何方法名一起使用，但是，如果通配符匹配具有<code>void</code>返回类型和非<code>void</code>返回类型的方法，则注入将失败并出错，因为对于非<code>void</code>的目标需要使用<code>CallbackInfoReturnable</code>。</p><h3 id="7-回调注入器的思考与局限性"><a href="#7-回调注入器的思考与局限性" class="headerlink" title="7. 回调注入器的思考与局限性"></a>7. 回调注入器的思考与局限性</h3><h4 id="7-1-注入构造方法"><a href="#7-1-注入构造方法" class="headerlink" title="7.1 注入构造方法"></a>7.1 注入构造方法</h4><p>现在Java代码中的构造方法相当简单，并限定了三个简单的约束：</p><ol><li>在任何其他代码之前都必须调用<code>super</code>。</li><li>必须初始化任何<code>final</code>字段。</li><li>作为第1点造成的结果，你不能在<code>super</code>调用中内联调用实例方法，这里进行的任何调用都必须是静态的。</li></ol><p>但在<em>字节码</em>层面，构造方法更加精致。由于编译后的<code>&lt;init&gt;</code>方法混杂着原先构造方法的代码，任何类的字段初始化器（复制到所有构造方法），以及在某些情况下合成的（编译器生成的）代码（例如<code>Enum</code>的构造方法）。由于它们的性质，它们就是字节码层面变换的雷区。</p><p>因此，Mixin对注入器施加以下限制：</p><ul><li><strong>为构造方法支持的唯一注入点是<code>RETURN</code>注入点</strong>。之所以强加此限制，是因为在调用处理方法代码之前，没有其他明智的方法可以确保类已经完全初始化。</li></ul><p>如果要注入构造方法，<strong>必须</strong>指定<code>RETURN</code>为注入点。</p><h4 id="7-2-故障状态"><a href="#7-2-故障状态" class="headerlink" title="7.2 故障状态"></a>7.2 故障状态</h4><p>像其他Mixin功能一样，回调注入器被设计为<em>快速失效</em>和<em>故障安全</em>的。这通常意味着如果注入器发生故障，它通常会做两件事之一：</p><ol><li>“静默”故障（除非启用了Mixin调试）并保持<strong>目标方法</strong>不变（但<strong>处理</strong>方法仍将合并到目标类中）。</li><li>使用确定性的错误消息故障：例如，当注入器找到其目标操作符，但<strong>处理</strong>方法有着不正确的签名时。</li></ol><p>注入器的设计使得任何故障都<strong>不会</strong>破坏方法字节码，它要么成功，要么绝对失败。</p><p>静默故障通常发生在注入点不匹配操作符的注入器上。当目标方法被更改或替换时可能会发生这种情况，并且可能非常有用，因为可以创建“重载”注入器来适应不同的情况。</p><p>然而，有时候注入器的成功是很重要的。也许应用程序的稳定取决于它，或者失败不是预期的状态，应用程序应该被关闭。无论那种方式，有时必须能够<em>确保</em>注入器成功（如果不成功，则引发故障状态）。使用<code>expect</code>和<code>require</code>参数是可能做到这一点的。</p><h5 id="7-2-1-Require"><a href="#7-2-1-Require" class="headerlink" title="7.2.1 Require"></a>7.2.1 Require</h5><p><code>require</code>参数很简单，为<code>require</code>指定特定值要求注入器必须成功<em>至少几次</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject(method = &quot;foo&quot;, at = @At(value = &quot;INVOKE&quot;, target = &quot;someMethod&quot;), require = 2)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onInvokeSomeMethodInFoo</span><span class="params">(CallbackInfo ci)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在本例中，我们希望我们的注入点匹配<strong>目标</strong>方法中的2个调用.指定<code>require</code>意味着如果少于2次注入结果，就会发生错误。</p><p>还可以在Mixin配置文件中为<code>require</code>指定一个配置域的值。</p><h5 id="7-2-2-Expect"><a href="#7-2-2-Expect" class="headerlink" title="7.2.2 Expect"></a>7.2.2 Expect</h5><p>有时在运行时故障是容许的，但是当开发Mixin时，你希望能够使用<code>require</code>功能（当注入失败时出错）而不必到处撒<code>require</code>，并且不需要记住在代码投入生产之前删除他！</p><p><code>expect</code>参数允许你精确地执行。<code>expect</code>的工作方式与<code>require</code>完全一样，除了它仅在将<code>mixin.debug.countInjections</code>系统属性设置为<code>true</code>是才对其进行处理。这允许你在开发检查注入器是否工作，并使它们在生产中快速失效。</p><h5 id="7-2-3-全局注入器设置"><a href="#7-2-3-全局注入器设置" class="headerlink" title="7.2.3 全局注入器设置"></a>7.2.3 全局注入器设置</h5><p>你可以在你的Mixin配置文件中为<code>require</code>指定一个配置域的默认值，其包含在一个<code>injectors</code>块中，你可以覆盖配置中的所有Mixin的<code>require</code>默认值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;injectors&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;defaultRequire&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="7-2-4-注入器组"><a href="#7-2-4-注入器组" class="headerlink" title="7.2.4 注入器组"></a>7.2.4 注入器组</h5><p>虽然<code>require</code>语句运行你规定单个注入器的行为额，但你可能会遇到希望为单个情境提供多个替代注入器的情况。如果Mixin面向多个环境，或者已知其他转换器已定义良好的方式修改特定目标方法，则这非常有用。</p><p>在这些情况下，你可以提供两个或多个注入器，其中对于给定的环境，只有一个预期成功。这当然提出了一个问题，即如何利用这些注入器的<code>require</code>值，因为如果在给定情景中预计至少有一个注入器会故障，那么这就不可能使用<code>require</code>。</p><p>为了解决这一问题，注入器支持<em>组</em>的声明。使用注入器组允许<em>为组</em>指定<code>min</code>和<code>max</code>注入次数，聪哥确保注入仍然可以验证为有效，但是应该只发生指定的注入次数。</p><p>为了使用注入器组，只需让每个注入器<strong>处理方法</strong>声明<code>@Group</code>注解。第一个注解应该指定<code>min</code>和（可选地）<code>max</code>。如果在单个Mixin中使用多个注入器组，那么应该在Mixin中的所有<code>@Group</code>注解上指定该组的唯一<code>name</code>。</p><h4 id="7-3-重写处理方法的行为"><a href="#7-3-重写处理方法的行为" class="headerlink" title="7.3 重写处理方法的行为"></a>7.3 重写处理方法的行为</h4><p>当定义回调注入器<strong>处理</strong>方法时，将使用正常的Mixin行为将方法合并到<strong>目标类</strong>中。然而，这对子类，特别是派生类型中定义的注入器有影响。</p><ul><li><p><strong>处理方法在合并前重命名</strong>——所有<strong>处理</strong>方法再被合并到目标类之前被<em>修饰</em>。这确保了如果<em>相同</em>类的另一个Mixin定义了<em>相同的</em>注入器，那么这两个处理方法将不会冲突。</p></li><li><p><strong>处理方法使用适合其访问级别的操作符来调用</strong>——如果你的处理方法是<code>private</code>，那么将使用<code>INVOKESPECIAL</code>（静态绑定）调用它，如果<strong>处理</strong>方法是非私有的，则将使用<code>INVOKEVIRTUAL</code>调用它，这将允许你在派生的Mixin中<code>@Override</code>处理方法。</p></li><li><p><strong>如果在派生的Mixin中<code>@Override</code>一个处理方法，它将被重命名以匹配其超Mixin对应方法的修饰</strong>——这样做是为了使得派生类中的方法永远不能“意外”覆盖你的<strong>处理</strong>方法。</p></li></ul><p>通常，除非明确计划为特定处理方法使用重写语句，否则建议<strong>处理</strong>方法是<code>private</code>的。</p><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>这似乎要思考很多，回调注入器功能强大，非常精细，因此这不是一种合理的思考方式！让我们回顾一下要点，把一切都理清楚：</p><ul><li><p>回调注入器只是常规的Mixin方法，具有<em>注入</em>回调到目标类中一些位置的特殊行为。</p></li><li><p>它们总是由目标内部的<strong>处理方法</strong>、<strong>目标方法</strong>和一些<em>注入点</em>组成。</p></li><li><p>回调注入器方法总是接收一个<code>CallbackInfo</code>，并且可以接收其他参数，例如<strong>目标</strong>方法的参数。</p></li><li><p>回调可以是<em>可取消的</em>，允许从目标方法提前返回。</p></li><li><p>对于注入器存在不同的故障处理方法，<code>require</code>是最有效的设置，你应该经常使用它。</p></li></ul><p>值得一提的是，回调注入器不能或不应该这样做：</p><ul><li><p>回调注入器<strong>不将处理方法代码注入目标</strong>，它们只注入<em>回调</em>。如果你想<em>返回</em>，请使用<em>可取消的注入</em>。</p></li><li><p>回调注入器<strong>不能随意注入构造方法</strong>，只有<code>RETURN</code>对构造方法注入器有效。</p></li></ul><h3 id="9-接下来做什么？"><a href="#9-接下来做什么？" class="headerlink" title="9. 接下来做什么？"></a>9. 接下来做什么？</h3><p>回调注入器仅是Mixin提供的最基本的注入器形式。在下列的教程文章中，我们将介绍其他更专业的注入器：</p><ul><li><p><strong><a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Capture-Locals">用回调注入器捕获局部变量</a></strong><br><br>A secondary feature of regular Callback Injectors, not covered in this introduction, is the ability to capture the local variables at the target location. In this article I introduce the concept of local capture, and the use of surrogates and argument coercion.</p></li><li><p><strong><a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Redirect-Injectors">介绍重定向注入器</a></strong><br><br>Probably the most powerful injector type. Redirect injectors allow a target method call or field access to be “redirected” to a custom callback. This type of injector can be leveraged extremely effectively to “wrap around” a method call, change the return value of a method call, or inhibit a method call altogether.</p></li><li><p><strong><a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---ModifyArg-Injectors">使用ModifyArg注入器修改方法调用参数</a></strong><br><br><strong>Redirect</strong>‘s baby brother, this type of injector allows a single argument to a method to be altered on-the-fly using a callback method.</p></li><li><p><strong><a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---ModifyVariable-Injectors">使用ModifyVariable注入器修改方法中的局部变量</a></strong><br><br>Whilst delicate and one of the more tricky injectors to use, <strong>ModifyVariable</strong> injectors are the only injector type which can directly edit the value of a local variable within a method.</p></li><li><p><strong><a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---ModifyConstant-Injectors">使用ModifyConstant注入器挂钩和修改文本值</a></strong><br><br>This type of injector can be used to turn a constant value used in a method into a method call to a callback. Extremely useful for hooking into loop logic, conditionals, or other “hard coded” parts of a target method that you wish to alter.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Callback-Injectors&quot;&gt;Advanced Mixin Usage C</summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>介绍 Nashorn —— Java 8 JavaScript 引擎</title>
    <link href="https://mouse0w0.github.io/2018/12/02/Introduction-to-Nashorn/"/>
    <id>https://mouse0w0.github.io/2018/12/02/Introduction-to-Nashorn/</id>
    <published>2018-12-02T11:07:03.000Z</published>
    <updated>2025-05-20T11:48:56.964Z</updated>
    
    <content type="html"><![CDATA[<p>本文我们来介绍一下Java 8的Nashorn JavaScript引擎。Nashorn是于Java 8中用于取代Rhino（Java 6，Java 7）的JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。与先前的Rhino引擎相比，它有二到十倍的性能提升。本文中将使用各种各样的例子来说明Nashorn的强大功能。</p><h2 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h2><p>jjs是个基于Nashorn引擎的命令行工具。你可以通过该工具快速地在Java上运行JavaScript代码，就像是一个REPL。</p><p>例如，运行一个<code>hello.js</code>文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="variable">$JAVA_HOME</span>/bin/jjs hello.js</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><p>或者，你还可以直接运行代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="variable">$JAVA_HOME</span>/bin/jjs</span></span><br><span class="line"><span class="meta prompt_">jjs&gt; </span><span class="language-bash"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><h2 id="在Java中调用Nashorn引擎"><a href="#在Java中调用Nashorn引擎" class="headerlink" title="在Java中调用Nashorn引擎"></a>在Java中调用Nashorn引擎</h2><p>本文专注于在Java中调用Nashorn，所以现在在Java代码中实现简单的HelloWorld：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByName(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line">engine.eval(<span class="string">&quot;print(&#x27;Hello World!&#x27;);&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>或者，我们还可以从文件中运行JS：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByName(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line">engine.eval(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;hello.js&quot;</span>));</span><br></pre></td></tr></table></figure></p><h2 id="编译JavaScript代码"><a href="#编译JavaScript代码" class="headerlink" title="编译JavaScript代码"></a>编译JavaScript代码</h2><p>你同样可以将脚本编译为Java字节码后调用，这样在多次调用的情况下效率会更高，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByName(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line"><span class="type">CompiledScript</span> <span class="variable">compiledScript</span> <span class="operator">=</span> ((Compilable) engine).complie(<span class="string">&quot;print(&#x27;Hello World!&#x27;);&quot;</span>);</span><br><span class="line">engine.eval();</span><br></pre></td></tr></table></figure></p><h2 id="传递数据到脚本"><a href="#传递数据到脚本" class="headerlink" title="传递数据到脚本"></a>传递数据到脚本</h2><p>数据可以通过定义<code>Bindings</code>传递到引擎中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bindings</span> <span class="variable">bindings</span> <span class="operator">=</span> engine.createBindings();</span><br><span class="line">bindings.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nashorn&quot;</span>);</span><br><span class="line"></span><br><span class="line">engine.eval(<span class="string">&quot;print(&#x27;Hello &#x27; + name);&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>运行该程序将输出<code>Hello Nashorn</code>。</p><h2 id="在Java中调用JavaScript函数"><a href="#在Java中调用JavaScript函数" class="headerlink" title="在Java中调用JavaScript函数"></a>在Java中调用JavaScript函数</h2><p>Nashorn支持从Java代码中直接调用定义在脚本中的JavaScript函数。你可以将Java对象作为函数参数传递，并且使用函数返回值调用Java方法。</p><p>例如在脚本中定义如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun1 = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="keyword">function</span> (<span class="params">object</span>) &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(object));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>为了调用函数，你首先需要将脚本引擎转换为<code>Invocable</code>接口。<code>NashornScriptEngine</code>已经实现了<code>Invocable</code>接口，并且定义了<code>invokeFunction</code>方法来调用指定名称的JavaScript函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ScriptEngine</span> engine = <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().<span class="title function_">getEngineByName</span>(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line">engine.<span class="built_in">eval</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;hello.js&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="title class_">Invocable</span> invocable = (<span class="title class_">Invocable</span>) engine;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span> result = invocable.<span class="title function_">invokeFunction</span>(<span class="string">&quot;fun1&quot;</span>, <span class="string">&quot;Nashorn&quot;</span>);</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(result);</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(result.<span class="title function_">getClass</span>());</span><br></pre></td></tr></table></figure><p>最终将输出如下内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello Nashorn</span><br><span class="line">Hi!</span><br><span class="line">java.lang.String</span><br></pre></td></tr></table></figure></p><p>Java对象在传入时不会在JavaScript上损失任何类型信息。由于脚本在JVM上运行，我们可以在Nashron上使用Java API或外部库的全部类或方法。</p><p>现在让我们传入任意Java对象来调用第二个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">invocable.invokeFunction(<span class="string">&quot;fun2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// [object java.util.Date]</span></span><br><span class="line"></span><br><span class="line">invocable.invokeFunction(<span class="string">&quot;fun2&quot;</span>, LocalDateTime.now());</span><br><span class="line"><span class="comment">// [object java.time.LocalDateTime]</span></span><br><span class="line"></span><br><span class="line">invocable.invokeFunction(<span class="string">&quot;fun2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"><span class="comment">// [object my.package.Person]</span></span><br></pre></td></tr></table></figure></p><h2 id="调用Java静态方法和字段"><a href="#调用Java静态方法和字段" class="headerlink" title="调用Java静态方法和字段"></a>调用Java静态方法和字段</h2><p>在JavaScript中调用Java方法非常容易，就像在Java中所做的一样。首先我们先定义一个Java静态方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后Java类就可以通过<code>Java.type</code>API在JavaScript中引用，就像Java的<code>import</code>一样，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyJavaClass</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">`my.package.MyJavaClass`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title class_">MyJavaClass</span>.<span class="title function_">sayHello</span>(<span class="string">&#x27;Nashorn&#x27;</span>);</span><br><span class="line"><span class="title function_">print</span>(result);</span><br></pre></td></tr></table></figure></p><p>最终的结果是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello Nashorn</span><br><span class="line">Hi!</span><br></pre></td></tr></table></figure></p><p>为了理解在使用JavaScript原生类型调用Java方法时，Nashorn是如何处理类型转换的。我们将通过简单的例子来展示：</p><p>下面的方法将打印实际的参数类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    System.out.println(obj.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们用JavaScript来调用该方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(<span class="number">127</span>);</span><br><span class="line"><span class="comment">// class java.lang.Integer</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(<span class="number">49.99</span>);</span><br><span class="line"><span class="comment">// class java.lang.Double</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// class java.lang.Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line"><span class="comment">// class java.lang.String</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">127</span>));</span><br><span class="line"><span class="comment">// class jdk.nashorn.internal.objects.NativeNumber</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// class jdk.nashorn.internal.objects.NativeDate</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>());</span><br><span class="line"><span class="comment">// class jdk.nashorn.internal.objects.NativeRegExp</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(&#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// class jdk.nashorn.internal.scripts.JO4</span></span><br></pre></td></tr></table></figure></p><h2 id="创建Java对象"><a href="#创建Java对象" class="headerlink" title="创建Java对象"></a>创建Java对象</h2><p>创建Java对象也如图调用Java方法一样简单，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">HashMap</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">`java.util.HashMap`</span>);</span><br><span class="line"><span class="keyword">var</span> mapDef = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="keyword">var</span> map100 = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><h2 id="访问Java类的补充说明"><a href="#访问Java类的补充说明" class="headerlink" title="访问Java类的补充说明"></a>访问Java类的补充说明</h2><p>同样，访问Java类不一定需要<code>Java.type</code>函数，可直接书写类名访问。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = my.<span class="property">package</span>.<span class="property">MyJavaClass</span>.<span class="title function_">sayHello</span>(<span class="string">&#x27;Nashorn&#x27;</span>);</span><br><span class="line"><span class="title function_">print</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapDef = <span class="keyword">new</span> java.<span class="property">util</span>.<span class="title class_">HashMap</span>();</span><br></pre></td></tr></table></figure></p><p>同样，为了方便，Nashorn默认提供了对几个Java包的访问，分别是：<code>com</code>、<code>edu</code>、<code>java</code>、<code>javafx</code>、<code>javax</code>和<code>org</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jjs&gt; java.lang</span><br><span class="line">[JavaPackage java.lang]</span><br><span class="line">jjs&gt; typeof java.lang</span><br><span class="line">object</span><br><span class="line">jjs&gt; java.lang.System</span><br><span class="line">[JavaClass java.lang.System]</span><br><span class="line">jjs&gt; typeof java.lang.System</span><br><span class="line">function</span><br><span class="line">jjs&gt; typeof java.lang.System == &quot;function&quot;</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><h2 id="语言扩展"><a href="#语言扩展" class="headerlink" title="语言扩展"></a>语言扩展</h2><p>Nashorn虽然是面向ECMAScript 5.1实现的但它提供了一些扩展，使JavaScript能更好的运用。</p><h3 id="类型数组"><a href="#类型数组" class="headerlink" title="类型数组"></a>类型数组</h3><p>JavaScript的原生数组是无类型的。Nashron允许你在JavaScript中使用Java的类型数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">IntArray</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&quot;int[]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="title class_">IntArray</span>(<span class="number">5</span>);</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">array[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">array[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">array[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    array[<span class="number">5</span>] = <span class="number">23</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">print</span>(e.<span class="property">message</span>);  <span class="comment">// Array index out of range: 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;17&quot;</span>;</span><br><span class="line"><span class="title function_">print</span>(array[<span class="number">0</span>]);  <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;wrong type&quot;</span>;</span><br><span class="line"><span class="title function_">print</span>(array[<span class="number">0</span>]);  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;17.3&quot;</span>;</span><br><span class="line"><span class="title function_">print</span>(array[<span class="number">0</span>]);  <span class="comment">// 17</span></span><br></pre></td></tr></table></figure></p><p><code>int[]</code>数组就像真实的Java整数数组那样。但在试图向数组添加非整数时，Nashron执行了一些隐式的转换。字符串会自动转换为整数，这十分便利。</p><h3 id="用foreach语句迭代数组或集合"><a href="#用foreach语句迭代数组或集合" class="headerlink" title="用foreach语句迭代数组或集合"></a>用foreach语句迭代数组或集合</h3><p>我们可以在JavaScript使用foreach语句迭代数组或集合：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="title function_">each</span> (<span class="keyword">var</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">  result+=i+<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ArrayList</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;java.util.ArrayList&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="title function_">each</span> (<span class="keyword">var</span> el <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="title function_">print</span>(el);  <span class="comment">// a, b, c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> java.<span class="property">util</span>.<span class="title class_">HashMap</span>();</span><br><span class="line">map.<span class="title function_">put</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;val1&#x27;</span>);</span><br><span class="line">map.<span class="title function_">put</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;val2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="title function_">each</span> (<span class="keyword">var</span> e <span class="keyword">in</span> map.<span class="title function_">keySet</span>()) &#123;</span><br><span class="line">    <span class="title function_">print</span>(e);  <span class="comment">// foo, bar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="title function_">each</span> (<span class="keyword">var</span> e <span class="keyword">in</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">    <span class="title function_">print</span>(e);  <span class="comment">// val1, val2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>在简单的函数声明中，可以省略括号<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"><span class="keyword">in</span></span>) ++<span class="keyword">in</span></span><br></pre></td></tr></table></figure></p><h3 id="条件捕获语句"><a href="#条件捕获语句" class="headerlink" title="条件捕获语句"></a>条件捕获语句</h3><p>可以添加特定的catch字句，这些字句仅在指定条件为真时才执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;BOOM&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e <span class="keyword">if</span> <span class="keyword">typeof</span> e === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&quot;String thrown: &quot;</span> + e);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&quot;this shouldn&#x27;t happen!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="用Object-setPrototypeOf设置对象原型"><a href="#用Object-setPrototypeOf设置对象原型" class="headerlink" title="用Object.setPrototypeOf设置对象原型"></a>用Object.setPrototypeOf设置对象原型</h3><p>Nashorn定义了一个API扩展，它使我们能够更改对象的原型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, newProto);</span><br></pre></td></tr></table></figure></p><p>一般认为该函数是对<code>Object.prototype.__proto__</code>的一个更好选择，因为它应该是在所有代码中设置对象原型的首选方法。</p><h3 id="Lambda表达式和数据流"><a href="#Lambda表达式和数据流" class="headerlink" title="Lambda表达式和数据流"></a>Lambda表达式和数据流</h3><p>每个人都热爱lambda和数据流 — Nashron也一样！虽然ECMAScript 5.1没有Java8 lmabda表达式的简化箭头语法，我们可以在任何接受lambda表达式的地方使用函数字面值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> java.<span class="property">util</span>.<span class="title class_">ArrayList</span>();</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;a1&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;a2&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;a3&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;b3&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;c1&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;c2&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;c3&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list</span><br><span class="line">    .<span class="title function_">stream</span>()</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> el.<span class="title function_">startsWith</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">sorted</span>()</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        <span class="title function_">print</span>(el);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// a1, a2, a3</span></span><br></pre></td></tr></table></figure></p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>Java类型可以由<code>Java.extend</code>轻易继承。如下所示，你甚至可以在脚本中创建多线程的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Runnable</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;java.lang.Runnable&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Printer</span> = <span class="title class_">Java</span>.<span class="title function_">extend</span>(<span class="title class_">Runnable</span>, &#123;</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&#x27;printed from a separate thread&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thread</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;java.lang.Thread&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Printer</span>()).<span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&#x27;printed from another thread&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// printed from a separate thread</span></span><br><span class="line"><span class="comment">// printed from another thread</span></span><br></pre></td></tr></table></figure></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>方法和函数可以通过点运算符或方括号运算符来调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">System</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;java.lang.System&#x27;</span>);</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="number">10</span>);              <span class="comment">// 10</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>[<span class="string">&quot;println&quot;</span>](<span class="number">11.0</span>);         <span class="comment">// 11.0</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>[<span class="string">&quot;println(double)&quot;</span>](<span class="number">12</span>);   <span class="comment">// 12.0</span></span><br></pre></td></tr></table></figure></p><p>当使用重载参数调用方法时，传递可选参数类型<code>println(double)</code>会指定所调用的具体方法。</p><h3 id="Java-Beans"><a href="#Java-Beans" class="headerlink" title="Java Beans"></a>Java Beans</h3><p>你可以简单地使用属性名称来向Java Beans获取或设置值，不需要显式调用读写器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Date</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;java.util.Date&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">date.<span class="property">year</span> += <span class="number">1900</span>;</span><br><span class="line"><span class="title function_">print</span>(date.<span class="property">year</span>);  <span class="comment">// 3918</span></span><br></pre></td></tr></table></figure></p><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><p>两个不同对象的属性可以绑定到一起：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">bindProperties</span>(o1, o2);</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(o1.<span class="property">foo</span>);    <span class="comment">// bar</span></span><br><span class="line">o1.<span class="property">foo</span> = <span class="string">&#x27;rab&#x27;</span>;</span><br><span class="line"><span class="title function_">print</span>(o2.<span class="property">foo</span>);    <span class="comment">// rab</span></span><br></pre></td></tr></table></figure></p><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><p>Nashorn在String原型上提供了两个简单但非常有用的扩展。这就是<code>trimRight</code>和<code>trimLeft</code>函数，它们可返回String得副本并删除空格：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">print</span>(<span class="string">&quot;   hello world&quot;</span>.<span class="title function_">trimLeft</span>());</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;hello world     &quot;</span>.<span class="title function_">trimRight</span>());</span><br></pre></td></tr></table></figure></p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>当前文件名，目录和行可以通过全局变量<code>__FILE__</code>、<code>__LINE__</code>和<code>__DIR__</code>获取：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">print</span>(__FILE__, __LINE__, __DIR__);</span><br></pre></td></tr></table></figure></p><h3 id="导入作用域"><a href="#导入作用域" class="headerlink" title="导入作用域"></a>导入作用域</h3><p>有时一次导入多个Java包会很方便。我们可以使用<code>JavaImporter</code>类，和<code>with</code>语句一起使用。所有被导入包的类文件都可以在<code>with</code>语句的局部域中访问到。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imports = <span class="keyword">new</span> <span class="title class_">JavaImporter</span>(java.<span class="property">io</span>, java.<span class="property">lang</span>);</span><br><span class="line"><span class="title function_">with</span> (imports) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="keyword">new</span> <span class="title class_">File</span>(__FILE__);</span><br><span class="line">    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(file.<span class="title function_">getAbsolutePath</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><p>下面的代码将Java的<code>List</code>转换为JavaScript原生数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> javaList = <span class="keyword">new</span> java.<span class="property">util</span>.<span class="title class_">ArrayList</span>();</span><br><span class="line">javaList.<span class="title function_">add</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">javaList.<span class="title function_">add</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">javaList.<span class="title function_">add</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> jsArray = <span class="title class_">Java</span>.<span class="title function_">from</span>(javaList);</span><br><span class="line"><span class="title function_">print</span>(jsArray);                                  <span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="title function_">print</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(jsArray));  <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure></p><p>下面的代码执行相反操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> javaArray = <span class="title class_">Java</span>.<span class="title function_">to</span>([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>], <span class="string">&quot;int[]&quot;</span>);</span><br></pre></td></tr></table></figure></p><h3 id="访问超类"><a href="#访问超类" class="headerlink" title="访问超类"></a>访问超类</h3><p>在JavaScript中访问被覆盖的成员通常比较困难，因为Java的super关键字在ECMAScript中并不存在。幸运的是，Nashron有一套补救措施。</p><p>首先我们需要在Java代码中定义超类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;super run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我在JavaScript中覆盖了SuperRunner。要注意创建新的Runner实例时的Nashron语法：覆盖成员的语法取自Java的匿名对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">SuperRunner</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;my.package.SuperRunner&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Runner</span> = <span class="title class_">Java</span>.<span class="title function_">extend</span>(<span class="title class_">SuperRunner</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> runner = <span class="keyword">new</span> <span class="title class_">Runner</span>() &#123;</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="variable language_">super</span>(runner).<span class="title function_">run</span>();</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&#x27;my run&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">runner.<span class="title function_">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// super run</span></span><br><span class="line"><span class="comment">// my run</span></span><br></pre></td></tr></table></figure></p><p>我们通过Java.super()扩展调用了被覆盖的SuperRunner.run()方法。</p><h3 id="神奇的noSuchProperty和noSuchMethod"><a href="#神奇的noSuchProperty和noSuchMethod" class="headerlink" title="神奇的noSuchProperty和noSuchMethod"></a>神奇的<strong>noSuchProperty</strong>和<strong>noSuchMethod</strong></h3><p>可以在对象上定义方法，每当访问未定义属性或调用未定义方法时，将调用该方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = &#123;</span><br><span class="line">    <span class="attr">__noSuchProperty__</span>: <span class="keyword">function</span> (<span class="params">propName</span>) &#123;</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&quot;Accessed non-existing property: &quot;</span> + propName);</span><br><span class="line">    &#125;,</span><br><span class="line">     </span><br><span class="line">    <span class="attr">__noSuchMethod__</span>: <span class="keyword">function</span> (<span class="params">methodName</span>) &#123;</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&quot;Invoked non-existing method: &quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">demo.<span class="property">doesNotExist</span>;</span><br><span class="line">demo.<span class="title function_">callNonExistingMethod</span>()</span><br></pre></td></tr></table></figure></p><p>这将输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accessed non-existing property: doesNotExist</span><br><span class="line">Invoked non-existing method: callNonExistingMethod</span><br></pre></td></tr></table></figure></p><h3 id="Java-asJSONCompatible-函数"><a href="#Java-asJSONCompatible-函数" class="headerlink" title="Java.asJSONCompatible 函数"></a>Java.asJSONCompatible 函数</h3><p>使用该函数，我们可以得到一个与Java JSON库期望兼容的对象。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> engine.eval(<span class="string">&quot;Java.asJSONCompatible(</span></span><br><span class="line"><span class="string">  &#123; number: 42, greet: &#x27;hello&#x27;, primes: [2,3,5,7,11,13] &#125;)&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;)obj;</span><br><span class="line">  </span><br><span class="line">System.out.println(map.get(<span class="string">&quot;greet&quot;</span>));</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;primes&quot;</span>));</span><br><span class="line">System.out.println(List.class.isAssignableFrom(map.get(<span class="string">&quot;primes&quot;</span>).getClass()));</span><br></pre></td></tr></table></figure></p><p>这将输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">[2, 3, 5, 7, 11, 13]</span><br></pre></td></tr></table></figure></p><h3 id="载入脚本"><a href="#载入脚本" class="headerlink" title="载入脚本"></a>载入脚本</h3><p>你可以在脚本引擎中载入其他JavaScript文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">load</span>(<span class="string">&#x27;classpath:script.js&#x27;</span>);</span><br></pre></td></tr></table></figure></p><p>或者通过URL载入脚本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">load</span>(<span class="string">&#x27;/script.js&#x27;</span>);</span><br></pre></td></tr></table></figure></p><p>请记住，JavaScript没有命名空间的概念，所以所有的内容都堆放在全局环境中。这使得加载的脚本有可能与你的代码或它们之间的命名冲突。这可以使用<code>loadWithNewGlobal</code>函数尽可能减少这种情况的发生：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="title function_">loadWithNewGlobal</span>(<span class="string">&#x27;classpath:math_module.js&#x27;</span>)</span><br><span class="line">math.<span class="title function_">increment</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p><code>math_module.js</code>的文件内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ++num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">math;</span><br></pre></td></tr></table></figure></p><p>这里我们定义了一个名为<code>math</code>的对象，其中有一个名为<code>increment</code>的函数。使用这个范例我们可以达成基本的模块化。</p><h2 id="ScriptObjectMirror"><a href="#ScriptObjectMirror" class="headerlink" title="ScriptObjectMirror"></a>ScriptObjectMirror</h2><p>在向Java传递原生JavaScript对象时，你可以使用<code>ScriptObjectMirror</code>类，它实际上是底层JavaScript对象的Java表示。<code>ScriptObjectMirror</code>实现了<code>Map</code>接口，其位于<code>jdk.nashorn.api</code>中。这个包中的类可以用于Java代码。</p><p>下面的例子将参数类型从<code>Object</code>改为<code>ScriptObjectMirror</code>，我们可以从传入的JavaScript对象中获得一些信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(ScriptObjectMirror mirror)</span> &#123;</span><br><span class="line">    System.out.println(mirror.getClassName() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">        Arrays.toString(mirror.getOwnKeys(<span class="literal">true</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当向这个方法传递对象（哈希表）时，在Java中可以访问其属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object: [foo, bar]</span></span><br></pre></td></tr></table></figure></p><p>我们也可以在Java中调用JavaScript的函数。让我们首先在JavaScript中定义一个<code>Person</code>类型，其含有属性<code>firstName</code>和<code>lastName</code>，以及函数<code>getFullName</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">firstName, lastName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getFullName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JavaScript方法<code>getFullName</code>可以通过<code>callMember()</code>在<code>ScriptObjectMirror</code>上调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(ScriptObjectMirror person)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Full Name is: &quot;</span> + person.callMember(<span class="string">&quot;getFullName&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当向Java方法传递新的<code>Person</code>时，我们会在控制台看到预计的输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Parker&quot;</span>);</span><br><span class="line"><span class="title class_">MyJavaClass</span>.<span class="title function_">fun</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Full Name is: Peter Parker</span></span><br></pre></td></tr></table></figure></p><h2 id="限制脚本对特定Java类的访问"><a href="#限制脚本对特定Java类的访问" class="headerlink" title="限制脚本对特定Java类的访问"></a>限制脚本对特定Java类的访问</h2><p><code>jdk.nashorn.api.scripting.ClassFilter</code>接口限制通过Nashorn运行的脚本对特定Java类的访问，为JavaScript代码对Java类的访问提供了细粒度的控制。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.api.scripting.ClassFilter;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.api.scripting.NashornScriptEngineFactory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassFilterTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyCF</span> <span class="keyword">implements</span> <span class="title class_">ClassFilter</span> &#123; <span class="comment">// 创建类过滤器</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exposeToScripts</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;java.io.File&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testClassFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;print(java.lang.System.getProperty(\&quot;java.home\&quot;));&quot;</span> +</span><br><span class="line">        <span class="string">&quot;print(\&quot;Create file variable\&quot;);&quot;</span> +</span><br><span class="line">        <span class="string">&quot;var File = Java.type(\&quot;java.io.File\&quot;);&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="type">NashornScriptEngineFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NashornScriptEngineFactory</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> factory.getScriptEngine(<span class="keyword">new</span> <span class="title class_">MyClassFilterTest</span>.MyCF());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            engine.eval(script);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception caught: &quot;</span> + e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClassFilterTest</span> <span class="variable">myApp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassFilterTest</span>();</span><br><span class="line">        myApp.testClassFilter();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>最终这会抛出<code>java.lang.ClassNotFoundException</code>异常。</p><h2 id="命令行脚本"><a href="#命令行脚本" class="headerlink" title="命令行脚本"></a>命令行脚本</h2><p>如果你对编写命令行（shell）脚本感兴趣，来试一试<a href="https://github.com/winterbe/nake">Nake</a>吧。Nake是一个Java 8 Nashron的简化构建工具。你只需要在项目特定的<code>Nakefile</code>中定义任务，之后通过在命令行键入<code>nake -- myTask</code>来执行这些任务。任务编写为JavaScript，并且在Nashron的脚本模式下运行，所以你可以使用你的终端、JDK8 API和任意Java库的全部功能。</p><p>对Java开发者来说，编写命令行脚本是前所未有的简单…</p><blockquote><p>本文部分内容来自：</p><p><a href="https://wizardforcel.gitbooks.io/modern-java/content/ch3.html">https://wizardforcel.gitbooks.io/modern-java/content/ch3.html</a></p><p><a href="https://docs.oracle.com/javase/10/nashorn/nashorn-java-api.htm">https://docs.oracle.com/javase/10/nashorn/nashorn-java-api.htm</a></p><p><a href="https://www.baeldung.com/java-nashorn">https://www.baeldung.com/java-nashorn</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文我们来介绍一下Java 8的Nashorn JavaScript引擎。Nashorn是于Java 8中用于取代Rhino（Java 6，Java 7）的JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。与先前的Rhino引擎相</summary>
      
    
    
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>插入式注解处理API（JSR269）介绍</title>
    <link href="https://mouse0w0.github.io/2018/11/27/Introduce-to-Pluggable-Annotation-Processing-API/"/>
    <id>https://mouse0w0.github.io/2018/11/27/Introduce-to-Pluggable-Annotation-Processing-API/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2025-05-20T11:48:56.953Z</updated>
    
    <content type="html"><![CDATA[<p>插入式注解处理API（<a href="https://www.jcp.org/en/jsr/detail?id=269">JSR269</a>）是用于处理注解（元数据，<a href="https://www.jcp.org/en/jsr/detail?id=269">JSR175</a>）的一套API。其API位于<code>javax.annotation.processing</code>和<code>javax.lang.model</code>包下。</p><p>插入式注解处理API可以让你在编译期访问注解元数据，处理和自定义你的编译输出，像反射一样访问类、字段、方法和注解等元素，创建新的源文件等等。可用于减少编写配置文件的劳动量，提高代码可读性等等。本文中我们将尝试着创建一个用于标识服务提供者的注解处理器，并同时讲解插入式注解处理API的相关内容。</p><blockquote><p>关于服务提供者和<code>ServiceLoader</code>是什么及其更多信息请浏览Java文档<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">java.util.ServiceLoader</a>。</p></blockquote><p>首先创建一个<code>@ServiceProvider</code>注解，该注解用于标识一个服务提供者类，其<code>value()</code>值为服务接口类的类对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceProvider &#123;</span><br><span class="line">    Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，我们为该注解创建一个注解处理器，注解处理器需实现<code>javax.annotation.processing.Processor</code>接口或继承<code>javax.annotation.processing.AbstractProcessor</code>类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProviderProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时，我们要在我们的源文件路径下的<code>META-INF/services</code>文件夹下，创建一个名为<code>javax.annotation.processing.Processor</code>的文本文件，其中写入我们的注解处理器的全称，例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.github.mouse0w0.jsr269.ServiceProviderProcessor</span><br></pre></td></tr></table></figure></p><p>在services下添加了注解处理器服务后，Java编译器就能够自动地发现你的注解处理器了。</p><p>现在的文件结构如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">|- com</span><br><span class="line">    |- github</span><br><span class="line">        |- mouse0w0</span><br><span class="line">            |- jsr269</span><br><span class="line">                |- ServiceProvider.java</span><br><span class="line">                |- ServiceProviderProcessor.java</span><br><span class="line">|- META-INF</span><br><span class="line">    |- services</span><br><span class="line">        |- javax.annotation.processing.Processor</span><br><span class="line">pom.xml</span><br></pre></td></tr></table></figure></p><p>为了能够让我们的项目能够通过编译，我们需要为Java编译器添加一个不进行注解处理的参数。假设我们使用Maven构建项目，那么在<code>pom.xml</code>文件中添加编译参数设置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">compilerArgument</span>&gt;</span>-proc:none<span class="tag">&lt;/<span class="name">compilerArgument</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这样，Java编译器就不会试图寻找我们的注解处理器了。</p><p>接下来介绍一下<code>ProcessingEnvironment</code>接口。该接口表示一个处理环境，可以通过实现<code>init(ProcessingEnvironment)</code>方法或使用<code>processingEnv</code>字段取得。它提供了许多接口用于与编译器、源文件和类文件的交互。有了它，你就可以发送编译信息（提示、警告甚至是错误等等），创建新的源文件或类文件。它的接口声明如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProcessingEnvironment</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,String&gt; <span class="title function_">getOptions</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息发送器，用于发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Messager <span class="title function_">getMessager</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回文件访问器，用于创建源文件、类文件或者其他文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Filer <span class="title function_">getFiler</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Elements <span class="title function_">getElementUtils</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Types <span class="title function_">getTypeUtils</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前的源代码版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SourceVersion <span class="title function_">getSourceVersion</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前的语言环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Locale <span class="title function_">getLocale</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们开始着手编写我们的注解处理器吧。首先我们需要重写两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> SourceVersion <span class="title function_">getSupportedSourceVersion</span><span class="params">()</span> &#123; <span class="comment">// 支持的源代码版本</span></span><br><span class="line">     <span class="keyword">return</span> SourceVersion.RELEASE_8;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSupportedAnnotationTypes</span><span class="params">()</span> &#123; <span class="comment">// 支持的注解类型</span></span><br><span class="line">     Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">     set.add(ServiceProvider.class.getName());</span><br><span class="line">     <span class="keyword">return</span> set;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>然后，向<code>process</code>方法中添加我们的代码逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; services = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!roundEnv.processingOver()) &#123; <span class="comment">// 判断是否为最终轮</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(ServiceProvider.class)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> TypeElement)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            addService(findAnnoValue(element, ServiceProvider.class.getName(), <span class="string">&quot;value&quot;</span>).getValue().toString(), ((TypeElement) element).getQualifiedName().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        saveAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果为true，则接下来的处理器不可处理该注解；如果为false，则接下来的处理器可以处理该处理器处理的注解。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AnnotationValue <span class="title function_">findAnnoValue</span><span class="params">(Element element, String annoType, String key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (AnnotationMirror anno : element.getAnnotationMirrors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ServiceProvider.class.getName().equals(anno.getAnnotationType().toString())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">ExecutableElement</span>, ? <span class="keyword">extends</span> <span class="title class_">AnnotationValue</span>&gt; entry : anno.getElementValues().entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(entry.getKey().getSimpleName().toString())) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(String service, String provider)</span> &#123;</span><br><span class="line">    services.computeIfAbsent(service, s -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(provider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : services.entrySet()) &#123;</span><br><span class="line">        <span class="type">FileObject</span> <span class="variable">fileObject</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileObject = processingEnv.getFiler().createResource(StandardLocation.CLASS_OUTPUT, <span class="string">&quot;&quot;</span>, <span class="string">&quot;META-INF/services/&quot;</span> + entry.getKey());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fileObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Cannot create file object for &quot;</span> + entry.getKey());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> fileObject.openWriter()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : entry.getValue()) &#123;</span><br><span class="line">                writer.append(s).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，你可以将注解处理器打包为Jar类库，然后由你的其他项目引用并构建。就会自动地在<code>META-INF/services</code>下生成对应的服务提供者文件了！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceProvider(MyService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，使用<code>ServiceLoader.load(MyService.class)</code>加载对应服务类的所有服务提供者实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (MyService service : ServiceLoader.load(MyService.class)) &#123;</span><br><span class="line">    System.out.println(service.getClass().getSimpleName()); <span class="comment">// 输出为MyServiceImpl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多关于插入式注解处理API的详细信息，请浏览Java文档<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/package-summary.html">javax.annotation.processing</a>和<a href="https://docs.oracle.com/javase/8/docs/api/javax/lang/model/package-summary.html">javax.lang.model</a>。</p><p>本文的源代码：<a href="https://github.com/mouse0w0/jsr269-example">https://github.com/mouse0w0/jsr269-example</a></p><blockquote><p>强烈建议使用Maven或Gradle等自动构建工具进行构建，否则你可能需要配置你的IDE以使用注解处理器。</p><p>后记：我实在是懒得写了……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;插入式注解处理API（&lt;a href=&quot;https://www.jcp.org/en/jsr/detail?id=269&quot;&gt;JSR269&lt;/a&gt;）是用于处理注解（元数据，&lt;a href=&quot;https://www.jcp.org/en/jsr/detail?id=269&quot;&gt;J</summary>
      
    
    
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>介绍Mixin——重写方法</title>
    <link href="https://mouse0w0.github.io/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/"/>
    <id>https://mouse0w0.github.io/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/</id>
    <published>2018-11-07T03:47:18.000Z</published>
    <updated>2025-05-20T11:48:56.954Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Overwriting-Methods"><br>Introduction to Mixins Overwriting Methods</a></p></blockquote><p>到目前为止，我们讲解的Mixin功能本质上都是<strong>增添</strong>，并且不会从根本上改变目标类的原始行为。但在两种情况下，我们可能希望Mixin修改或替换目标类中的内容：</p><ol><li>我们希望更改现有方法的行为。</li><li>我们希望在已经存在的目标类中定义一个访问器，但是它的名称在被混淆后可能发生变化。</li></ol><p>这两种情况都需要我们能够<strong>重写</strong>目标类中的某些部分。</p><h3 id="1-房间里的大象-重写"><a href="#1-房间里的大象-重写" class="headerlink" title="1. 房间里的大象 - 重写"></a>1. 房间里的大象 - 重写</h3><p><em>重写（Overwrite）</em>是Mixin中最微妙的功能，通常应尽量使用<a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Rerouters">回调注入器（Callback Injectors）</a>、<a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Callback-Injectors">重路由器（Rerouters）</a>或其他Mixin代码注入功能。</p><p>让我们花一点时间来回顾我们在<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Understanding-Mixin-Architecture#6-is-it-a-bird-is-it-a-plane-no-its-superclass">本教程的第一部分</a>中的例子，使用Mixin将<code>setLevel</code>方法添加到目标类中：</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_19.png" alt></p><p>Mixin中含有没有多余修饰的附加方法，并且该方法将被添加到目标类中。在Mixin应用之后，该方法将存在于目标类中，就好像它一直存在一样。我已经用<img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_21.png" alt>标记了Mixin方法，以便于合并时更容易找到它：</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_20.png" alt></p><p>因此，下一个问题是：<em>如果我们在Mixin中声明一个 <strong>已经存在于目标类中的方法</strong>，会发生什么？</em></p><p>答案是，<strong><em>Mixin</em> 方法完全重写了 <em>原始</em> 方法</strong>。</p><h4 id="1-1-声明重写方法"><a href="#1-1-声明重写方法" class="headerlink" title="1.1 声明重写方法"></a>1.1 声明重写方法</h4><p>让我们来看一个简单的例子。我们将假定<code>EntityPlayer</code>中的<code>getLevel()</code>方法不按接口所需的方式运行。也许按照接口约定，调用<code>getLevel()</code>应该总是返回非负值，但<code>EntityPlayer</code>的内部代码不能避免负等级，我们希望避开这种情况。</p><p>我们将为<code>getLevel()</code>定义一个遵守接口约定的新方法体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(EntityPlayer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinEntityPlayer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Entity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">LivingThing</span>, Leveller &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Shadow</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法重写了目标类中的getLevel方法</span></span><br><span class="line"><span class="comment">     * 并确保它返回非负值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="built_in">this</span>.level, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> newLevel)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//... 以下代码略.</span></span><br></pre></td></tr></table></figure><p>现在，当应用Mixin时，在Mixin中定义的<code>getLevel()</code>方法将重写现有的对应部分：</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_22.png" alt></p><p>最后类的结构与之前没有什么不同，但包含了我们在<code>getLevel()</code>方法中定义的新逻辑。</p><h4 id="1-2-能力越大，责任越大"><a href="#1-2-能力越大，责任越大" class="headerlink" title="1.2 能力越大，责任越大"></a>1.2 能力越大，责任越大</h4><p>早就应该指出，<strong>重写不是万能的</strong>，它有许多相当明显的缺点，在选择使用它时应该小心。缺点包括但不限于：</p><ul><li>重写完全清除之前应用于该方法的任何转换。这意味着任何其他使用转换器来修改目标方法的Mod都将清除它们的修改。这可能导致另一个Mod，甚至整个游戏变得不稳定。</li><li>和其他Mod一样，其他重写相同方法的Mixin也会发生冲突。拥有最高<strong>优先级</strong>的Mixin将取胜，并且只有来自该Mixin的重写才会实际出现在目标类中。如果稍后有Mixin试图重写拥有较高优先级的Mixin重写的方法，就会发出警告。</li><li>重写更复杂的方法可能导致重写“过时”。例如，如果你决定用原始代码的修改版重写一个方法，那么就应该负责确保该代码在你的Mixin中与其目标保持一致。你可以用<a href="#3-约束">约束</a>（见下文）来帮助你做到这点。</li><li>使用重写可能会导致过早秃头和在交通中大声喊叫的倾向。</li></ul><p>因此，你应该慎重考虑是否使用重写。经过考究，一些适合使用重写的地方是：</p><ul><li><p><strong>简单的方法，例如访问器</strong><br>在这些场景中使用重写以用额外逻辑修饰访问器，可以快速高效地添加诸如参数验证之类的功能。由于获取器和设置器不多变，使用重写来修改它们是快速和直接的。然而，你仍然应该考虑使用<a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Callback-Injectors">注入器（Injector）</a>是否更合适。</p></li><li><p><strong>快速原型</strong><br>重写可以方便的另一个地方是，当原型改变，你打算稍后更改使用<a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Callback-Injectors">回调注入器（Callback Injector）</a>的方法时。在Mixin中复制原始方法可以快速简单地在开发过程中创建一个“补丁”，尤其是当试图确定最好的方法来改变以适合你需要的方法的行为时。</p></li><li><p><strong>注入器根本无力做到的情况</strong><br>虽然<a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Callback-Injectors">回调注入器</a>非常强大，但它们的作用域是有限的，并且你偶尔会遇到它们不符合要求的情况，尤其是在非常复杂或庞大的方法中。与其他情况一样，当选择重写时，应该极度不情愿，但有时这是不得已而为之的。</p></li><li><p><strong>小心那根绳子</strong><br>重写就像是会吊死你的长绳。通过设立一套制度来持续管理所有重写，确保重写不会回头伤害你。我建议你至少：</p><ul><li><strong>当</strong>有人添加重写时，用注释解释<strong>所有</strong>重写的方法，解释<strong>为什么</strong>要使用重写，<strong>谁</strong>添加了重写。持续复查这些注释，以确保重写仍然是必要和有意义的。</li><li>当使用“复制和修改”方式重写时，以原始方法体作为起点，在方法体中<strong>注释你做出的修改</strong>。如果目标方法更改，这将更容易提取和合并更改。</li><li>解释任何用于原型的重写，或“将其转换为注入器”，以便它们不会在代码库中停留过长的时间。</li><li>使用<a href="#3-约束">约束</a>来为重写添加一个健全的检查，下面的章节中提供更多关于这的详细信息。</li></ul></li></ul><h4 id="1-3-讨厌的混淆边界"><a href="#1-3-讨厌的混淆边界" class="headerlink" title="1.3 讨厌的混淆边界"></a>1.3 讨厌的混淆边界</h4><p>你可能想知道<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Obfuscation-and-Mixins">上一节</a>中为什么如此详细地定义了我们所谓的 <em><a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Obfuscation-and-Mixins#2-resolving-the-identity-crisis---defining-the-obfuscation-boundary">混淆边界</a></em>。你可能还记得那部分：</p><blockquote><p>任何Mixin特定机制……<strong>将始终使用某种注解进行修饰</strong>。这使得<a href="https://github.com/SpongePowered/Mixin/wiki/Using-the-Mixin-Annotation-Processor">Mixin注解处理器（Annotation Processor）</a> 能够找到它们，并将处理它们的混淆。</p></blockquote><p>……事实上就是这样。</p><p>如果你仔细想想，这是完全合乎逻辑的：重写方法不会“知道”它将重写一个目标方法<em>直到应用Mixin</em>，此时，它发现它的目标点已经存在原始方法，并且达成了它的重写任务。当不涉及混淆时，这是可行的，但是当存在混淆时，这是非常痛苦的，因为我们需要一些方法“链接”重写与所需的目标方法，以便让注解处理器生成混淆表条目。</p><p>为了做到这一点，我们使用一个简单的注解<code>@Overwrite</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加注解到重写中，将其与将被混淆的目标方法链接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Overwrite</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="built_in">this</span>.level, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-1-使用-Overwrite-注解"><a href="#1-3-1-使用-Overwrite-注解" class="headerlink" title="1.3.1 使用 @Overwrite 注解"></a>1.3.1 使用 <code>@Overwrite</code> 注解</h5><p>用<code>@Overwrite</code>来修饰一个方法会使注解处理器在编译时寻找目标方法。如果没有找到混淆映射，注解处理器将发出一个错误。</p><p>这意味着：</p><ul><li><p>在你的Mixin中为一个不是混淆的方法定义一个<strong>重写</strong>，你应该简单地<strong>声明方法</strong>。</p></li><li><p>为一个混淆方法定义一个<strong>重写</strong>，你应该<strong>声明该方法并用<code>@Overwrite</code>注解注解它</strong>。</p></li></ul><p>你还应该记住，任何包含重写方法的Mixin<em>不能超出目标类的范围</em>。原因是，即使所有目标类在MCP环境中定义具有相同名称和相同签名的方法，但这并不表示所有混淆环境的每个方法都具有唯一名称。可能可以使用别名来解决此问题，但这是不推荐的。</p><h4 id="1-4-Overwrite-注解的其他用法"><a href="#1-4-Overwrite-注解的其他用法" class="headerlink" title="1.4 @Overwrite 注解的其他用法"></a>1.4 <code>@Overwrite</code> 注解的其他用法</h4><p><code>@Overwrite</code>注解还有一个最终用途。为目标类中的<code>public static</code>方法定义重写。</p><p>默认情况下，在Mixin中声明一个<code>public static</code>方法会引起<code>Id10t Error</code>，因为无法调用以这种方式定义的方法！然而应该知道的是，重写为这种无意义的操作提供了一个用例。用<code>@Overwrite</code>注解方法将绕过限制，并允许在Mixin中定义<code>public static</code>方法。</p><h3 id="2-固有代理方法"><a href="#2-固有代理方法" class="headerlink" title="2. 固有代理方法"></a>2. 固有代理方法</h3><p>虽然常规的重写的行为易于理解和相当可预测，但是它们缺乏灵活性，给Mixin设计来带了一些挑战，而这些挑战不容易克服。好消息是Mixin提供了内置功能来应对这些问题，坏消息是这个功能最初看起来会相当复杂。为了更清楚地理解这些功能，我们将逐步解决这个问题。</p><h4 id="2-1-The-Intrinsic-Quack-and-the-Obfuscated-Duck-Hunt"><a href="#2-1-The-Intrinsic-Quack-and-the-Obfuscated-Duck-Hunt" class="headerlink" title="2.1 The Intrinsic Quack and the Obfuscated Duck Hunt"></a>2.1 The Intrinsic Quack and the Obfuscated Duck Hunt</h4><p>Mixin的关键任务之一是通过使用Mixin将自己的接口应用到现有对象，在Java应用程序中提供伪鸭子类型功能。有时现有类中的方法<em>已经</em>实现了接口方法，我们称这种类型的方法为<em>固有（Intrinsic）</em>方法，因为它是现有类的一部分：实际上我们的类已经——从本质上——就知道如何嘎嘎叫。</p><p>但是有一个问题：如果固有方法被混淆了会发生什么？答案是——对象一旦被混淆，就不再会嘎嘎叫，一旦越过混淆边界，接口约定就会被破坏。</p><p>让我们来看一个简单的例子。在本例中，我们将使用与前一篇文章中相同的类和接口，但我们将假设<code>Identifyable</code>接口不会与目标对象冲突：</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_24.png" alt></p><p>正如我们所见的，Mixin中不需要实现<code>getID</code>，因为类<code>Foo</code>本质上已经实现了接口。但是，混淆之后，类、字段和方法名称都发生了变化，我们遇到了一个问题：</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_25.png" alt></p><p>既然方法不再有实现，任何使用者如果试图调用该方法，都会引发<code>AbstractMethodError</code>。</p><p>有一个使用我们已知功能的方法可以解决这个问题：</p><ul><li><p><strong>用原始方法的副本重写该方法</strong><br>这似乎是最直白的，当然也是最简单的方法。如我们所知，省略<code>@Overwrite</code>注解会导致重写<em>不</em>被混淆。这意味着，在我们的开发环境中（方法和字段名不被混淆），该方法将简单地重写目标中的现有方法：</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_26.png" alt></p><p>在混淆之后，重写神奇地转换为<em>新</em>的访问器，因为方法合并的语义意味着该方法将简单地添加到目标类：</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_27.png" alt></p></li></ul><p>这种方法的两个主要缺点是，首先，它需要将原始方法复制到Mixin中，这对于简单的访问器来说是可以接受的，但对于更复杂的方法可能是有问题的，因为它再次使我们处于需要手动保持功能与目标方法等同的处境。如果目标方法改变，那么我们必须更新重写。其次，我们可能最终需要为那些我们并不真正感兴趣的字段创建影子，并且宁愿通过现有类的公共约定（例如，通过原始访问器）进行访问，而对于更复杂的方法，这可能有更多的影子字段。除了复制原始方法的功能之外，我们对这些字段并不真正感兴趣，因此添加它们只会造成代码混乱。</p><p><strong>固有代理（Intrinsic Proxy）</strong>方法允许我们在出现这种情况时对重写过程进行细粒度控制（Finer-grained Control）。</p><h4 id="2-2-The-Polite-Overwrite-Won’t-Fight-for-the-Right-to-um…-Blight"><a href="#2-2-The-Polite-Overwrite-Won’t-Fight-for-the-Right-to-um…-Blight" class="headerlink" title="2.2 The Polite Overwrite Won’t Fight for the Right to um… Blight?"></a>2.2 The Polite Overwrite Won’t Fight for the Right to um… Blight?</h4><p>我们可以通过引入一种新的重写方式来改善这种状况，具体来说：</p><ul><li><code>“不要重写已经存在的（固有的）方法”</code></li></ul><p>在此情况下，我们创建了上述重写，但是用<code>@Intrinsic</code>注解来修饰它。这有效地声明了重写是针对固有方法的，如果找到了方法，则不应该进行重写。</p><p>虽然这不是一个巨大的改进，但从所有外部代码（目标代码库中的代码）的视角来看，它确实意味着方法的<em>*原始约定保证被保留</em>，这减少了底层方法可能发生的更改，并且不必担忧发生的更改在我们的重写中反映出来。通过运行原始方法始终存在，并且只在生产中添加我们的新方法（供我们自己的代码使用），我们有机会能稍微提高些稳定性。</p><h4 id="2-3-代理固有方法"><a href="#2-3-代理固有方法" class="headerlink" title="2.3 代理固有方法"></a>2.3 代理固有方法</h4><p>当然，这仍然意味着，调用我们的鸭子类型接口的<em>代码</em>调用方法，可能最终与基于环境的方法的不同实现交互，这取决于方法的性质。我们真正希望能够做的是调用原始方法，并在它周围封装一些我们自己的逻辑。</p><p>幸运的是，我们可以把我们的重写定义为一个<strong>固有代理</strong>。</p><p><strong>固有代理方法（Intrinsic Proxy Method）</strong>通过改变重写的行为以工作，使得<em>原始</em>方法是被<em>移动</em>而不是重写。然后，我们可以在所有情况下从重写中调用<em>原始</em>方法。然而，为了定义新的代理方法，我们需要<code>@Shadow</code>原始方法——这会产生冲突。幸运的是，我们确切地知道如何处理冲突：我们使用<strong>软实现</strong>！</p><p>让我们在确切的方向上迈出一小步，将新的访问器转换为软实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(Foo.class)</span></span><br><span class="line"><span class="meta">@Implements(@Interface(iface = Indentifyable.class, prefix = &quot;id$&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinFoo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Shadow</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法将成为我们的固有代理方法，</span></span><br><span class="line"><span class="comment">     * 它调用访问器的原始（影射）版本。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id$getID() &#123;</span><br><span class="line">        <span class="comment">// 调用原访问器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在应用Mixin时，前缀将被删除，这意味着在Mixin合并之后，我们将以冲突结束。正如我们所知，Mixin会把这个冲突当作一个<em>重写</em>，让我们回到起点！</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_28.png" alt></p><p>然而，情况变得更糟，因为新方法中对<code>this.getID()</code>的调用<strong>现在变成了自引用</strong>，如果调用该方法，将导致堆栈溢出，因为它将递归地调用自己，直到JVM用完堆栈空间！</p><p>这就是我们的新朋友<code>@Intrinsic</code>再次拯救的地方。<code>@Intrinsic</code>注解具有间接行为，如果目标固有方法已经存在，则它允许目标固有方法不被替换，而是被移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法将成为我们的固有代理方法，</span></span><br><span class="line"><span class="comment"> * 它调用访问器的原始（影射）版本。</span></span><br><span class="line"><span class="comment"> * 当方法被重写时，</span></span><br><span class="line"><span class="comment"> * 使用displace参数以避免重入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intrinsic(displace = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> id$getID() &#123;</span><br><span class="line">    <span class="comment">// 调用原始访问器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加<code>displace</code>参数会导致固有重写以以下方式表现：</p><ul><li>如果固有对应项不存在（例如，如果方法在具有不同名称的混淆环境中），则新代理方法将像往常一样简单地添加到目标类中。</li><li>如果固有对应项确实存在，那么会发生三件事：<ol><li>将固有项重命名为新名称。</li><li>代理中对固有项的引用将被更新为新名称。</li><li>然后将代理方法像以前一样添加到目标类中。</li></ol></li></ul><p>这种新的方式使我们自食其力，因为我们确保自己的代码总是调用代理方法，而且原始访问器的约定也总是保持不变。我们还不需要为任何不相关的目标类成员添加影子，而只需要为固有对应项添加影子，从而使得Mixin代码更加清晰。</p><p>我们的新Mixin行为图是这样的：</p><p><img src="/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/mixin_tut_29.png" alt></p><h3 id="3-约束"><a href="#3-约束" class="headerlink" title="3. 约束"></a>3. 约束</h3><p>如上所述，为了避免破坏目标程序，需要仔细地使用重写功能。虽然在Mixin代码库中对重写使用严格的管理方案会有很大的帮助，但是在现实中管理你的产品可能更棘手，特别是当用户在意外环境中部署你的产品时，例如，使用你打算混合的软件的较新版本。</p><p>因此，约束提供了此前没有的健全检查，前提是你能够提供相关信息到可能需要约束的环境。</p><h4 id="3-1-在应用程序环境中管理约束"><a href="#3-1-在应用程序环境中管理约束" class="headerlink" title="3.1 在应用程序环境中管理约束"></a>3.1 在应用程序环境中管理约束</h4><p>约束采用与单个整数值相关联的字符串标记的形式。这些标记的值必须通过<em>标记提供器（Token Provider）</em>的实例与<code>MixinEnvironment</code>注册到Mixin环境中。</p><p>标记完全取决于你，但一般来说，你将希望表示目标应用程序环境的某些方面。假设你能够从应用程序的单例实例中获取目标应用程序的构建号：一个简单的标记提供程序可能如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTokenProvider</span> <span class="keyword">implements</span> <span class="title class_">ITokenProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;BUILD&quot;</span>.equals(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> TargetApplication.getInstance().getBuildNumber();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该标记提供器为标记<code>BUILD</code>返回了应用程序构建号。它为所有其他标记返回<code>null</code>以表示提供器不支持这个标记。在<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---The-Mixin-Environment">引导Mixin库</a><br>时，我们必须注册标记提供器的实例。</p><h4 id="3-2-使用约束"><a href="#3-2-使用约束" class="headerlink" title="3.2 使用约束"></a>3.2 使用约束</h4><p>一旦我们在环境中定义了标记，我们就可以定义对重写的约束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overwrite(constraints = &quot;BUILD(1234)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someHackyOverwrite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="comment">// 做一些修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该修改方法用一个约束来定义，该约束指示标记<code>BUILD</code><strong>必须被定义</strong>，并且<strong>其值必须为1234</strong>。如果不满足此约束，则Mixin处理器将发生错误并使应用程序崩溃。</p><p>我们也可以定义在一定区间内定义约束，定义一系列可以写入的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overwrite(constraints = &quot;BUILD(1230-1240)&quot;)</span></span><br></pre></td></tr></table></figure><p>这允许在1230到1240（包括）之间的值通过，并且也可以写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overwrite(constraints = &quot;BUILD(1230+10)&quot;)</span></span><br></pre></td></tr></table></figure><p>下面给出了约束标识符的完整列表：</p><table>    <thead>        <tr>            <th>约束字符串</th>            <th>意义</th>        </tr>    </thead>    <tbody>        <tr>            <td valign="top"><tt>()</tt></td>            <td valign="top">该标记必须存在于环境中，但可以有任何值</td>        </tr>        <tr>            <td valign="top"><tt>(1234)</tt>            </td><td valign="top">标记值必须为<tt>1234</tt></td>        </tr>        <tr>            <td valign="top"><tt>(1234+)</tt><br><tt>(1234-)</tt><br><tt>(1234&gt;)</tt></td>            <td valign="top">所有这些变体都有相同的意义，都可以认为是“1234及以上”</td>        </tr>        <tr>            <td valign="top"><tt>(&lt;1234)</tt></td>            <td valign="top">小于1234</td>        </tr>        <tr>            <td valign="top"><tt>(&lt;=1234)</tt></td>            <td valign="top">小于或等于1234（相当于<tt>1234&lt;</tt>）</td>        </tr>        <tr>            <td valign="top"><tt>(&gt;1234)</tt></td>            <td valign="top">大于1234</td>        </tr>        <tr>            <td valign="top"><tt>(&gt;=1234)</tt></td>            <td valign="top">大于或等于1234（相当于<tt>1234&gt;</tt>）</td>         </tr>        <tr>            <td valign="top"><tt>(1234-1300)</tt></td>            <td valign="top">值必须在1234至1300（包括）之间</td>         </tr>        <tr>            <td valign="top"><tt>(1234+10)</tt>            </td><td valign="top">值必须在1234至1234+10之间（1234-1244包括）</td>        </tr>    </tbody></table><p>可以被表示为整数的目标环境的任何特征都可以作为约束的基础。例如，布尔状态可以表示为1或0。</p><h4 id="3-3-选择约束"><a href="#3-3-选择约束" class="headerlink" title="3.3 选择约束"></a>3.3 选择约束</h4><p>究竟使用哪种约束取决于环境，以及预计方法的变动性。例如，重写一个简单的访问器可认为比重写一个复杂的访问器风险要小得多，因此可以得到更大的约束。对于极易变的方法（在本例中，变动性是方法改变的可能性），那么较小的约束可能是个好主意。</p><p>当然，确切值的“大小”将取决于标记，例如，在一个每天有多个构建的项目上使用构建号，“小”的值可能是100。而对于一个每年只变化几次的项目来说，“小”的值可能是2。当在环境中定义标记时使用你的判断，并在应用程序的开发人员说明中说明标记的预期变动。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>重写和固有代理提供了强大的功能，但是必须仔细设计它们，同时考虑诸多因素，并应尽可能避免使用重写和固有代理。</p><p>使用重写作为代码库中的另一个工具，可以在设计Mixin时提供很大的灵活性和权利，不计后果地使用它们，并且不考虑潜在的陷阱，这几乎肯定会在你的应用程序生命周期之后导致问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Overwriting-Methods&quot;&gt;&lt;br&gt;Introduction to</summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>介绍Mixin——解决方法签名冲突</title>
    <link href="https://mouse0w0.github.io/2018/11/06/Introduction-to-Mixins-Resolving-Method-Signature-Conflicts/"/>
    <id>https://mouse0w0.github.io/2018/11/06/Introduction-to-Mixins-Resolving-Method-Signature-Conflicts/</id>
    <published>2018-11-06T03:15:29.000Z</published>
    <updated>2025-05-20T11:48:56.957Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本教程翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Resolving-Method-Signature-Conflicts">Introduction to Mixins Resolving Method Signature Conflicts</a></p></blockquote><p>Mixin给我们很大的权利去操作现有的类，其中最有用的就是如<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Understanding-Mixin-Architecture">本系列第一部分所说</a>的添加新接口到现有的类。</p><p>然而，当我们与希望添加接口的目标类及其父类中的现有方法有方法声明冲突时，就会出现问题。让我们来看一个简单的例子，看看问题是在哪发生的：</p><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>在我们的示例程序中，我们希望标记某些对象，以便跟踪它们的实例。我们定义一个名为<code>Identifyable</code>的新接口，它有一个名为<code>getID()</code>的方法，并将其组合到我们想要识别的目标类中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Identifyable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取该对象的ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> UUID <span class="title function_">getID</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们选择使用Java的<code>UUID</code>类来作为标识符类型，并打算为组合的每个对象生成一个唯一的<code>UUID</code>示例。</p><p>但是，如果我们的一个目标类的父类已经定义了一个返回类型不同签名的方法，那么Java编译器就不会让我们编译我们的Mixin。为了知道原因，让我们来看看我们试图创建的代码结构。我已经用返回类型修饰了每个访问器来表明问题：</p><p><img src="/2018/11/06/Introduction-to-Mixins-Resolving-Method-Signature-Conflicts/mixin_conflict_0.png" alt></p><p>父类中的<code>getID()</code>方法和我们试图定义的<code>getID()</code>方法仅在返回类型上不同。这种类型的重载Java并不支持，编译器也会在编译Mixin时发生错误：</p><p><img src="/2018/11/06/Introduction-to-Mixins-Resolving-Method-Signature-Conflicts/mixin_conflict_1.png" alt></p><p>然而，运行Java的引擎Java虚拟机（Java Virtual Machine，JVM）隐藏着一丝希望：JVM本身<strong>支持</strong>这种重载，只是Java语言不支持而已。这意味着，如果能够让编译器编译我们的代码，那么实际的类就可以正常工作了。</p><h3 id="2-绕过编译机制-浑水摸鱼"><a href="#2-绕过编译机制-浑水摸鱼" class="headerlink" title="2. 绕过编译机制 - 浑水摸鱼"></a>2. 绕过编译机制 - 浑水摸鱼</h3><p>如果Java不允许我们访问JVM，那么如何利用隐藏的功能呢？简单：我们使用一个假的方法来编译Mixin，并在应用Mixin时用我们想要的实际方法来交换它。我们的解决方案的第一阶段看起来是这样的：</p><p><img src="/2018/11/06/Introduction-to-Mixins-Resolving-Method-Signature-Conflicts/mixin_conflict_2.png" alt></p><p>在本例中，我们将下划线（<code>_</code>）作为方法的前缀，并在应用Mixin时使用重命名操作来从方法名中除去下划线。我们还从Mixin中删除了接口声明，因为编译器仍足够聪明，即使在接口上定义方法也能够发现冲突。</p><p>所以现在我们知道了解决冲突方法的方法，但有两个新问题：</p><ul><li><p>Mixin处理器如何知道哪些方法需要去除前缀，以及前缀是什么？</p></li><li><p>当这样做会立刻引起与目标的冲突时，我们如何在Mixin上实现接口？</p></li></ul><p>幸运的是，这两个问题都可以很容易地解决！</p><h3 id="3-轻轻的来-软实现一个接口"><a href="#3-轻轻的来-软实现一个接口" class="headerlink" title="3. 轻轻的来 - 软实现一个接口"></a>3. 轻轻的来 - <em>软实现</em>一个接口</h3><p>为了解决这些问题，我们将引入一个新的概念，即<strong>软实现（Soft Implementing）</strong>接口的思想。</p><p>对于软实现，我们将定义用于接口中的方法的前缀，这解决了第一个问题，以及不实际使用<code>implements</code>关键字，声明接口实现的方法，这解决了第二个问题。</p><p><img src="/2018/11/06/Introduction-to-Mixins-Resolving-Method-Signature-Conflicts/mixin_conflict_3.png" alt></p><p>就最终效果来说，软实现提供了与让Mixin直接实现接口的完全相同的功能，换句话说：</p><ul><li>软实现的接口仍以与常规接口相同的方式被添加到目标类上。</li><li>有前缀的方法仍然组合到目标类中（包括Overwrite语句——参见下节），并且只需要由Mixin处理器除去任意前缀。</li></ul><blockquote><p><strong>注意</strong>也可以在同一个Mixin中混合使用“硬”和“软”实现。</p></blockquote><h4 id="3-1-声明软实现"><a href="#3-1-声明软实现" class="headerlink" title="3.1 声明软实现"></a>3.1 声明软实现</h4><p>如你所想，使用注解来声明软实现。让我们来看看上述例子是如何变为Java代码的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(Bar.class)</span></span><br><span class="line"><span class="meta">@Implements(@Interface(iface = Indentifyable.class, prefix = &quot;ident$&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinBar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">UUID</span> <span class="variable">id</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UUID ident$getID() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在<code>@Implements</code>语句中，我们可以指定一个或多个<code>@Interface</code>注解来描述想要实现的接口。前缀的选择完全取决于你，但我建议在选择前缀时使用如下准则：</p><ul><li><p>前缀以<script type="math/tex">`符号结束。`</script>通常被用作Java类的合成与结构部分中的分隔符，有助于将前缀与有前缀的方法名分开。例如<code>foo$getId()</code>比<code>foogetID()</code>更容易解析为两部分。如果您选择不使用<code>$</code>，那我建议使用下划线（<code>_</code>）作为合理的选择。</p></li><li><p>使用一个简短的字符串，它使人了解到该前缀所关联的接口，这更加容易将前缀方法与其软实现的接口联系起来。例如，选择<code>ident$</code>作为<code>Identifyable</code>接口的前缀，<code>id$</code>或<code>ifbl$</code>也是可用的，虽然允许使用更长的名称，例如使用<code>identifyable$</code>是完全合法的，但会导致代码难以阅读。同样，使用过于简短或不相关的名字是合法的，例如<code>foo$</code>或<code>a$</code>，但并不鼓励。</p></li></ul><p>注意，软实现接口的方法不<strong>必须</strong>使用前缀，实际上只有如上所述会冲突的方法需要使用前缀。然而，使用前缀是有益的，因为它使Mixin处理器在应用程序时进行一些额外的验证。如果稍后在接口中删除或更改方法，则检查有前缀的方法在声明的接口中的成员关系，从而使其变为可检查到的错误。</p><h3 id="4-回看部分问题"><a href="#4-回看部分问题" class="headerlink" title="4. 回看部分问题"></a>4. 回看部分问题</h3><p>因此，当实现父类中存在冲突方法的接口时，可能会发生签名冲突，但是目标类中的方法也会发生签名冲突。你可能会问自己，<em>“但是为何？当然与目标类不会发生冲突，因为编译器在编译Mixin时不知道目标类中的方法？”</em></p><p>答案当然是影子方法。</p><p>你也许还记得，在本系列的第一部分中，我们可以<em>*通过“影射”来告诉Mixin处理器目标类中的方法和字段</em>，但当我们想添加的影子方法与我们添加的接口方法有签名冲突时，这当然造成一个问题。</p><p>让我们修改上述示例，删除<code>Bar</code>，假设我们直接混入<code>Foo</code>：</p><p><img src="/2018/11/06/Introduction-to-Mixins-Resolving-Method-Signature-Conflicts/mixin_conflict_4.png" alt></p><p>我们可以很快发现，由于签名冲突，我们不能在目标类中添加<code>getID()</code>的影射。</p><p>幸运的是，Mixin处理器为我们提供了两种解决方案：</p><ul><li>首先，我们可以<strong>使用软实现</strong>，就像上文所说，我们可以将接口实现变软以绕过编译器限制。</li></ul><p>然而，当实现一个大型接口，仅单个（或至少少量）影子方法造成冲突时，这可能会带来不便。</p><ul><li>或者，Mixin允许我们为影子方法加上前缀。</li></ul><p>当少量影子导致问题时这是非常有用的，我们可以简单地重命名影子本身，以避免冲突。</p><h4 id="4-1-给影子加上前缀"><a href="#4-1-给影子加上前缀" class="headerlink" title="4.1 给影子加上前缀"></a>4.1 给影子加上前缀</h4><p>与软实现不同，这没有单独的地方来定义影子方法的前缀。相反，前缀可以直接在Shadow注解中定义，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinFoo</span> <span class="keyword">implements</span> <span class="title class_">Identifyable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Shadow(prefix = &quot;conflict$&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> conflict$getID();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UUID <span class="title function_">getID</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回唯一ID</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免签名冲突，我们为影子定义了前缀<code>conflict$</code>。Mixin还提供了前缀的默认值，这可以在不显式定义前缀的情况下使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Shadow</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> shadow$getID();</span><br></pre></td></tr></table></figure><p>使用前缀<code>shadow$</code>可以重命名影子，而不需要显式地定义前缀。然而，为了提高可读性，建议在注释中始终明确地定义<code>prefix</code>，即使使用默认值。</p><h3 id="5-扩展延伸"><a href="#5-扩展延伸" class="headerlink" title="5. 扩展延伸"></a>5. 扩展延伸</h3><p>前缀和软实现在<strong>内部代理方法（Intrinsic Proxy Methods）</strong>中也扮演着重要的角色，我们将在下一节中讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本教程翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Resolving-Method-Signature-Conflicts&quot;&gt;I</summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>如何在VSCode中配置C/C++ Debug</title>
    <link href="https://mouse0w0.github.io/2018/11/03/How-to-configurate-c-c-debug-in-vscode/"/>
    <id>https://mouse0w0.github.io/2018/11/03/How-to-configurate-c-c-debug-in-vscode/</id>
    <published>2018-11-03T12:34:10.000Z</published>
    <updated>2025-05-20T11:48:56.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载并安装MinGW"><a href="#下载并安装MinGW" class="headerlink" title="下载并安装MinGW"></a>下载并安装MinGW</h2><p>首先进入<a href="http://www.mingw.org/">MinGW官网</a>，点击Download按钮。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Download_1.png" alt="MinGW Download"></p><p>进入下载页面后，点击<strong>MinGW Installation Manager (mingw-get)</strong>。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Download_2.png" alt="MinGW Download"></p><p>进入mingw-get的下载页面后，点击<strong>Show</strong>按钮，然后分别下载<strong>mingw-get-0.6.3-mingw32-pre-20170905-1-bin.tar.xz</strong>和<strong>mingw-get-0.6.3-mingw32-pre-20170905-1-gui.tar.xz</strong>文件（此过程可能需要挂VPN）。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Download_3.png" alt="MinGW Download"></p><blockquote><p>注意：其实直接用<code>mingw-get-setup.exe</code>安装MinGW也可以，略去了解压步骤。</p></blockquote><p>两个文件下载完成后，将其解压至同一文件夹中。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Unzip.png" alt="MinGW Unzip"></p><p>进入MinGW目录下的<code>libexec\mingw-get</code>文件夹，点击<code>guimain.exe</code>运行。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_GUI.png" alt="MinGW GUI"></p><p>等待MinGW载入完成，这个过程可能很长。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Loading.png" alt="MinGW Loading"></p><p>加载完成后看起来如图所示，其中<strong>Basic Setup</strong>是基本要安装的，<strong>All Packages</strong>则包含了所有可以安装的包，具体各包的作用我们在此不做深入探讨了。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Loaded.png" alt="MinGW Loaded"></p><p><strong>右键单击</strong>想要安装的项目，选择<strong>Mark for Installation</strong>对想要安装的项目进行标记，同时该项目的依赖项也会被标记为需要安装。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Mark.png" alt="MinGW Mark for Installation"></p><p>在<strong>All Packages</strong>中找到<code>mingw32-gcc-g++-bin</code>和<code>mingw32-gdb-bin</code>，标记它们为需要安装的项目，此时它们的依赖项也会被同时标记。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Mark_2.png" alt="MinGW Mark for Installation"></p><p>点击左上角菜单栏的<strong>Installation</strong>，选择<strong>Apply Changes</strong>，在弹出的界面中再点击<strong>Apply</strong>开始安装所选的项目。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Installation.png" alt="MinGW Installation"></p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Installation_2.png" alt="MinGW Installation"></p><p>等待它安装完成，这个过程可能会很长。安装完成后点击<strong>Close</strong>按钮即可。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Installing.png" alt="MinGW Installing"></p><p>在<strong>计算机-系统属性-高级系统设置-环境变量</strong>将<code>MinGW\bin</code>添加到<code>Path</code>中。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Env_Var.png" alt="MinGW Environment Variable"></p><p>打开<code>cmd</code>，输入<code>gcc -v</code>，输出如下信息即表示安装成功。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/MinGW_Cmd.png" alt="MinGW Command Line"></p><h2 id="配置VSCode"><a href="#配置VSCode" class="headerlink" title="配置VSCode"></a>配置VSCode</h2><p>在扩展中搜索C，然后选择<code>C/C++</code>插件进行安装。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Install_C.png" alt="VSCode Install C"></p><p>安装完成后重启，并打开一个文件夹作为C/C++开发的工作空间。</p><p>点击上方菜单栏中的<strong>调试-打开配置</strong>。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Configurate_1.png" alt="VSCode Configurate"></p><p>在打开的<code>launch.json</code>文件里面，添加如下内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置类型，这里只能为cppdbg</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 程序调试时传递给程序的命令行参数，一般设为空即可</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 设为true时程序将暂停在程序入口处，一般设置为false</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">// 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 调试时是否显示外部控制台窗口</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\gdb.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// miDebugger的路径，注意这里要与MinGw的路径对应</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span> <span class="comment">// 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>结果如下所示：</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Configurate_2.png" alt="VSCode Configurate"></p><p>然后保存<code>launch.json</code>文件。</p><p>然后点击上方菜单栏中的<strong>终端-配置任务…</strong>。然后选择<strong>使用模板创建 tasks.json 文件</strong>，再选择<strong>Others 运行任意外部命令的示例</strong>，这将打开一个<code>tasks.json</code>文件。</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Configurate_3.png" alt="VSCode Configurate"></p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Configurate_4.png" alt="VSCode Configurate"></p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Configurate_5.png" alt="VSCode Configurate"></p><p>在打开的<code>tasks.json</code>文件中写入以下内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-fexec-charset=GBK&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 编译命令参数</span></span><br><span class="line">    <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fileLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;relative&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;regexp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;severity&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>结果如下所示：</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Configurate_6.png" alt="VSCode Configurate"></p><p>接下来，我们编写一个HelloWorld程序，然后测试它：</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_HelloWorld.png" alt="Hello World"></p><p>点击上方菜单栏的<strong>调试-非调试启动</strong>以开始运行：</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Run.png" alt="VSCode Run"></p><p>最终结果如下所示：</p><p><img src="/2018/11/03/How-to-configurate-c-c-debug-in-vscode/VSCode_Successful.png" alt="VSCode Successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;下载并安装MinGW&quot;&gt;&lt;a href=&quot;#下载并安装MinGW&quot; class=&quot;headerlink&quot; title=&quot;下载并安装MinGW&quot;&gt;&lt;/a&gt;下载并安装MinGW&lt;/h2&gt;&lt;p&gt;首先进入&lt;a href=&quot;http://www.mingw.org/&quot;&gt;Mi</summary>
      
    
    
    
    
    <category term="C/C++" scheme="https://mouse0w0.github.io/tags/C-C/"/>
    
    <category term="VSCode" scheme="https://mouse0w0.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>介绍Mixin——混淆与Mixin</title>
    <link href="https://mouse0w0.github.io/2018/11/02/Introduction-to-Mixins-Obfuscation-and-Mixins/"/>
    <id>https://mouse0w0.github.io/2018/11/02/Introduction-to-Mixins-Obfuscation-and-Mixins/</id>
    <published>2018-11-02T04:39:35.000Z</published>
    <updated>2025-05-20T11:48:56.953Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Obfuscation-and-Mixins">Introduction to Mixins Obfuscation and Mixins</a></p></blockquote><p>在我们进一步研究Mixin架构之前，先让我们绕过它去讨论另一个重要主题：Minecraft代码库中的<em>混淆</em>以及它与Mixin的关系。</p><blockquote><p><em>混淆（Obfuscation）</em>是将原本人类可读的代码符号转换为混淆的代码符号的过程，使得人难以阅读它（事实上，<em>混淆</em>这个词的意思仅仅是“<em>故意使模糊</em>”）。</p></blockquote><h3 id="1-在混淆时代的开发生命周期"><a href="#1-在混淆时代的开发生命周期" class="headerlink" title="1. 在混淆时代的开发生命周期"></a>1. 在混淆时代的开发生命周期</h3><p>由于Minecraft是使用Java编写的，如果不使用混淆技术，则很容易将其反编译为可读代码。Mojang在发布之前对Minecraft进行了混淆，这对模组开发者造成了问题，原因有两个：</p><ol><li>混淆的使用将所有的内容都放在“默认包”中，这使得无法从代码库<code>import</code>类。</li><li>使用混淆后的名称将是一场噩梦，因为代码基本上不可读。</li></ol><p>这就意味着，为了能够基于Minecraft编译我们的代码，有必要预先对Java类进行<strong>反</strong>混淆处理，一个名为<em>Mod Coder Pack</em>（简称MCP）的社区项目提供了遍历的方法。</p><p>一旦我们编写了代码，我们需要<strong>重</strong>混淆我们的Mod代码，以便它可以与原始的（混淆的）代码库一起工作。因此，开发生命周期看起来如下图所示：</p><p><img src="/2018/11/02/Introduction-to-Mixins-Obfuscation-and-Mixins/obfuscation_lifecycle.png" alt="混淆生命周期"></p><h3 id="2-化解识别危机-定义“混淆边界”"><a href="#2-化解识别危机-定义“混淆边界”" class="headerlink" title="2. 化解识别危机 - 定义“混淆边界”"></a>2. 化解识别危机 - 定义“混淆边界”</h3><p>让我们从基础知识开始：</p><p>当在开发Minecraft Mod时，字段和方法<strong>至多有3个名称</strong>：</p><ol><li><p><strong>混淆名（简称“OBF名”）</strong> - 这是Mojang分配的名称，作为其<em>混淆</em>代码库的一部分，它通常只有1-2个字母长，例如，一个混淆方法也许名为<code>k</code>。</p></li><li><p><strong>“Searge名”（简称“SRG名”）</strong> - 这是一个分配给字段或方法的唯一的代号，以便使反编译成为可能。它由前缀、唯一ID和成员的（原始）名称组成，例如<code>func_1234_k</code>。</p></li><li><p><strong>“MCP名”</strong> - 这是一个来自社区的更可读的名字，以便使代码库更容易理解。例如<code>getHealth</code>。</p></li></ol><p>在反编译过程中，字段将从一种名称转换为另一种名称，最终止于“友好的”<em>MCP名</em>。在重混淆过程中，反向进行处理。在我们的示例中，方法<code>k</code>变为<code>func_1234_k</code>最终变为<code>getName</code>。</p><p>在每个阶段<strong>所有</strong>字段和方法被重命名，因此每组混淆形成不相关的混淆<em>环境</em>，所有字段和方法具有对应于该环境的名称：</p><p><img src="/2018/11/02/Introduction-to-Mixins-Obfuscation-and-Mixins/obfuscation_environments.png" alt="混淆环境"></p><p>我们还将把这些假想环境之间的假想边界称为“<em>混淆边界（Obfuscation Boundary）</em> ”，因为显然<em>跨越</em>边界可能会造成问题。例如，方法<code>getHealth</code>（MCP名）总是希望<code>takeDamage</code>方法在任何特定执行周期都是它的MCP名称，如果同时存在来自不同环境的名称，那么很有可能发生问题。</p><h3 id="3-如何工作"><a href="#3-如何工作" class="headerlink" title="3. 如何工作"></a>3. 如何工作</h3><p>混淆环境之间的转换必须“同时进行”，并且有<em>映射文件（Mapping File）</em>的协助，文件中包含一个名称到另一个名称的映射。这些映射文件包含一个条目，用于代码库中的<em>每一个</em>字段、方法、参数和类。</p><blockquote><p>严格来说，这并不正确，因为MCP名是多人管理的，所以有很多成员没有定义MCP名，但是现在我们假装所有混淆都一直存在，因为现在并不需要讨论该例外。让我们设想一下，未映射的MCP名与SRG名是相同的。</p></blockquote><p>为了确保不仅重命名了符号的声明，而且重命名了对该符号的所有引用，必须同时将重映射应用于整个代码库。虽然SRG名是唯一的并且可以被确定性地重映射，但其他的符号并不那么简单，因此重映射工具需要同时载入和理解整个代码库以便有效进行重映射。</p><p>正因为工具以这种方式工作，对代码结构和关系<em>有</em>一个基本的了解（例如，派生类中重写的方法），所以重映射器才能够重映射对混淆类的引用，甚至在不属于源代码库的类中。通过这种方式，派生类（例如我们在模组中添加的类）和有对重映射方法调用的类（比如我们可以在模组中添加的类）<em>也</em>将重映射这些方法的调用和字段的访问！</p><h3 id="4-与Mixin的关系"><a href="#4-与Mixin的关系" class="headerlink" title="4. 与Mixin的关系"></a>4. 与Mixin的关系</h3><p>你可能想知道为什么你需要了解上述内容，它和Mixin有什么关系？现在你应该清楚的是：</p><ol><li>要以某种方式与游戏类交互的<strong>所有内容</strong>都<strong>必须</strong>通过混淆工具才能用于生产环境。</li><li>任何<strong>直接引用</strong>游戏中的字段、方法和类的东西，都将由重映射器自动处理，因为重映射器已经<strong>理解</strong>了这些关系。</li></ol><p>然而，这并不符合Mixin的情况，因为我们可以在Mixin中创建影子字段和方法，而不是直接引用它们的对应物！</p><h4 id="4-1-处理影子字段和方法的混淆"><a href="#4-1-处理影子字段和方法的混淆" class="headerlink" title="4.1 处理影子字段和方法的混淆"></a>4.1 处理影子字段和方法的混淆</h4><p>你可能会回想起本系列<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Understanding-Mixin-Architecture#5-to-light-a-candle-is-to-cast-a-shadow">第一部分</a>，可以将<em>影子</em>成员添加到我们的Mixin中，以指定在运行时目标类中存在的特定方法或字段。这导致的主要问题是混淆器没有建立对这些成员的理解，从而将无法自动混淆它们。</p><p>Mixin通过在编译时解析<code>@Shadow</code>注解，并将影子成员的适当混淆条目直接添加到混淆表中，以解决这个问题。这是由<a href="https://github.com/SpongePowered/Mixin/wiki/Using-the-Mixin-Annotation-Processor">注解处理器</a>处理的，它插入到Java编译器中。</p><p>众所周知，混淆器已经能够理解派生类中的字段和方法的引用，因此我们只需要为影子成员本身添加混淆表条目，然后自动处理对那些成员的引用。然后，Mixin可以安全地通过混淆边界。</p><h4 id="4-2-其他Mixin特性的混淆"><a href="#4-2-其他Mixin特性的混淆" class="headerlink" title="4.2 其他Mixin特性的混淆"></a>4.2 其他Mixin特性的混淆</h4><p>在本系列之后的内容，你将了解到其他Mixin特性，这些特性需要通过特殊处理来通过混淆边界。在此之上要记住的关键是：</p><ul><li><p>你的Mixin中的任何<strong>直接引用</strong>游戏代码库中的类将被自动处理，例如：</p><ul><li>当Mixin从游戏类派生时，引用父类方法。</li><li>你的Mixin中任何复写了游戏类或接口中的方法的<code>@Override</code>方法。</li><li>你的Mixin中任何对游戏类或成员的外部引用。</li></ul></li><li><p>任何<strong>Mixin特定机制</strong>，例如<em>Shadow</em>、<em>Overwrite</em>（将在下一节中介绍）和<em>Injector</em>（将在稍后介绍），将始终使用某种注解进行修饰。这使得<a href="https://github.com/SpongePowered/Mixin/wiki/Using-the-Mixin-Annotation-Processor">Mixin注解处理器（Annotation Processor）</a> 能够发现它们，它将处理它们的混淆。</p></li></ul><h3 id="5-The-Nitty-Gritty"><a href="#5-The-Nitty-Gritty" class="headerlink" title="5. The Nitty Gritty"></a>5. The Nitty Gritty</h3><p>如果你正在阅读本系列的介绍，你应该在这里停一下。以下部分提供了一些更详细的技术细节，并且仅出于完整性考虑，这将在之后的部分中引用。它们并不打算仅仅只是介绍一下而已，现在已经给你打过预防针了。</p><h4 id="5-1-“硬”与“软”混淆引用"><a href="#5-1-“硬”与“软”混淆引用" class="headerlink" title="5.1 “硬”与“软”混淆引用"></a>5.1 “硬”与“软”混淆引用</h4><p>传递到SpecialSource<a href="#note1"><sup>1</sup></a>的符号引用当然会像我们预期的那样被重混淆，并且底层字节码中的引用也会因此被重混淆。这种“硬”的重混淆适用于以下类型的成员：</p><ul><li>类引用（仅当混淆到“Notch名”<a href="#note2"><sup>2</sup></a>时，不会应用于Forge）</li><li>方法名</li><li>字段名</li></ul><p>但是，某些成员引用在注解中定义为字符串，特别是：</p><ul><li>Injector声明</li><li>Rerouter声明</li></ul><p>由于SpecialSource不能重映射这些“软”引用，所以使用不同的机制</p><h5 id="5-1-1-Mixin引用映射"><a href="#5-1-1-Mixin引用映射" class="headerlink" title="5.1.1 Mixin引用映射"></a>5.1.1 Mixin引用映射</h5><p>为了允许混淆“软”引用，<a href="https://github.com/SpongePowered/Mixin/wiki/Using-the-Mixin-Annotation-Processor">注解处理器</a>处理映射文件，该映射文件被包含在生产用Jar中，并在<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---The-Mixin-Environment#mixin-configuration-files">配置文件</a>中指定。这个<em>引用表（Reference Map，或简称“refmap”）</em>包含Mixin集合中所有到它们混淆的对象的软引用。</p><p>每个编译阶段都放出一个引用映射，因此在对应转换期间编译的每个Mixin集合都应该对该转换使用相同的引用映射。应该选择引用映射的唯一名称以避免冲突。</p><p>例如，假设我们在模组中定义如下的Mixin集合：</p><pre><code>mixins.myproject.core.jsonmixins.myproject.extra.json</code></pre><p>我们可以为这两个集合定义一个引用映射文件，并将其命名为<code>mixins.myproject.refmap.json</code>以使其一致。</p><p>注意，在生产用Jar中包含引用映射文件是绝对重要的，并要在Mixin配置中制定他。如果不这样做，将会在Mixin应用时导致错误，因为Mixin的引用将不由Mixin处理器解决。</p><p>在如下情况下，可以省略引用映射文件：</p><ul><li>你的Mixin里没有使用Injector和Rerouter。</li></ul><h4 id="5-2-运行时反混淆与Mixin"><a href="#5-2-运行时反混淆与Mixin" class="headerlink" title="5.2  运行时反混淆与Mixin"></a>5.2  运行时反混淆与Mixin</h4><p>一些特定环境使用部分运行时反混淆。也就是说，它们在运行时将符号反混淆为中间名（SRG名），而其他的则不反混淆。这个部分的转换是为了让模组能够有更稳定的混淆环境，以实现跨多个版本的游戏的目标。</p><p>显然，在应用运行时反混淆后，将Mixin字节码和目标类组合是非常重要的，因此环境中的混淆映射需与Mixin中的混淆映射相匹配。让我们重新看看前文中的图，转换器链中的Mixin概述：</p><p><img src="/2018/11/02/Introduction-to-Mixins-Obfuscation-and-Mixins/mixin_transformer_chain.png" alt></p><p>当我们考虑在此图中（在上游转换器链中）在哪里应用运行时反混淆时，我们可以看到反混淆转换器本身如何表示混淆边界，以及为什么必须在该转换器的下游应用Mixin：</p><p><img src="/2018/11/02/Introduction-to-Mixins-Obfuscation-and-Mixins/mixin_transformer_chain_obf.png" alt></p><h4 id="5-3-不可预测的成员名称-合成把戏的困扰"><a href="#5-3-不可预测的成员名称-合成把戏的困扰" class="headerlink" title="5.3  不可预测的成员名称 - 合成把戏的困扰"></a>5.3  不可预测的成员名称 - 合成把戏的困扰</h4><p>OBF -&gt; SRG -&gt; MCP的确定性规则的例外是目标类中的合成成员（Synthetic Member）<a href="#note3"><sup>3</sup></a>造成的。虽然混淆代码库中的合成成员也像它们的外部类一样具有混淆名称，但是在开发中会出现问题，因为重新建立的内部类关系导致这些合成成员被剥离，然后被编译器重新创建。</p><p>例如，让我们思考一个非静态内部类对其外部类的引用，通常在由<code>javac</code>生成的类中将其命名为<code>this$0</code>。当被混淆时，这个成员会得到一个使人混乱的名称“<code>a</code>”，并且在反编译过程中交替地重命名为“<code>field_999_a</code>”，最后才得到易于理解的MCP名称“<code>myOuter</code>”。然而，由于在建立开发工作环境的最后阶段就是在源代码中重新集成内部类及其外部类，因此，最终将剥离合成字段，并允许编译器重新创建该字段，从而在原先的“<code>this$0</code>”开发工作空间中给该字段一个名称。</p><p>这造成了一个问题，如果我们希望影射该字段，那么必须将其命名为<code>myOuter</code>（因为映射文件中出现的值就是这样命名的），但如果这样做，那么Shadow在开发时就不能工作，因为实际上并不存在名为<code>myOuter</code>的字段！</p><h5 id="5-3-1-别名"><a href="#5-3-1-别名" class="headerlink" title="5.3.1 别名"></a>5.3.1 别名</h5><p>可以通过指定影子字段的<em>别名</em>来解决这个问题。当试图定位影子字段的目标时，别名作为Mixin处理器的最后一个解决方案存在。如果Mixin处理器无法在目标类中找到所需的字段，那么它会首先检查别名列表，然后再出现错误。</p><p>若要指定Shadow或者Overwrite注解的别名，只需要在注释上确定<code>aliases</code>的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Shadow(aliases = &#123;&quot;this$0&quot;&#125;)</span></span><br><span class="line"><span class="keyword">private</span> MyOuterClassType myOuter;</span><br></pre></td></tr></table></figure></p><p>请注意，别名只能用于<code>private</code>字段和方法。这是因为别名只能在Mixin应用时解析，因此字段的重命名只能涉及到所包含的类，而不能进一步扩散（因为此时可能已经加载并使用了派生的类Mixin或其他引用类）。然而，这通常不是问题，因为作为别名机制的起因的合成字段几乎总是私有的或者是包私有的。</p><blockquote><p>译者注：</p><p><a name="note1"><sup>1</sup></a>SpecialSource是Jar混淆映射的自动生成器和重命名器，通常被用于Minecraft反混淆和重混淆的混淆映射表的生成。</p><p><a name="note2"><sup>2</sup></a>Notch名其实就是混淆名（又叫OBF名）。</p><p><a name="note3"><sup>3</sup></a>合成成员（Synthetic Member）是由Java编译器生成的一种特殊的字段（如非静态内部类就有一个引用父类的合成字段）、方法（例如泛型的桥方法，且内部类引用了外部类的字段或方法都会产生相应的合成方法）或类。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Obfuscation-and-Mixins&quot;&gt;Introduction to </summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>介绍Mixin——Mixin环境</title>
    <link href="https://mouse0w0.github.io/2018/11/01/Introduction-to-Mixins-The-Mixin-Environment/"/>
    <id>https://mouse0w0.github.io/2018/11/01/Introduction-to-Mixins-The-Mixin-Environment/</id>
    <published>2018-11-01T09:18:21.000Z</published>
    <updated>2025-05-20T11:48:56.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---The-Mixin-Environment">Introduction to Mixins The Mixin Environment</a></p></blockquote><p>现在我们已经了解了Mixin的<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Understanding-Mixin-Architecture/">基本特性</a>（提示：如果你还没有读过，请返回并先阅读它！），让我们快点绕开它，来了解如何使用我们的新创建的Mixin进入游戏环境。</p><h4 id="Mixin是如何工作的"><a href="#Mixin是如何工作的" class="headerlink" title="Mixin是如何工作的"></a>Mixin是如何工作的</h4><p>正如我在上一篇<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Understanding-Mixin-Architecture/">文章</a>中所提到的，通常情况下，最好记住<strong>Mixin不是严格意义上的类</strong>，也不是在运行时加载的类，而是使用<a href="http://asm.ow2.org/">ASM</a>的Tree API解析的原始字节码。这个API生成一个基于节点的底层字节码视图，然后可以通过Mixin转换器（Transformer）<a href="#note1"><sup>1</sup></a>合并到目标类中。</p><p>Mixin本身是独立于常规类，通过转换器链（Transformer Chain）<a href="#note2"><sup>2</sup></a>传输的，这是为了允许重映射转换器（Remapping Transformer）<a href="#note3"><sup>3</sup></a>在Mixin与目标类组合之前完成它们的工作。因此，Mixin转换器在任何重映射转换器的<em>下游</em>是很重要的，这是通过在转换器链中插入代理转换器（Proxy Transformer）来内部处理的。</p><p><img src="/2018/11/01/Introduction-to-Mixins-The-Mixin-Environment/mixin_transformer_chain.png" alt="Mixin转换器链"></p><p>Mixin需要在类开始载入之前进行处理，以便识别它们的<strong>目标类</strong>，进行<a href="https://github.com/SpongePowered/Mixin/wiki/About-Hierarchy-Validation-in-Mixins"><strong>层次结构验证</strong></a>，并为方法和字段解析任何需要更新的<strong>静态绑定</strong>。你希望使用的Mixin应该在配置文件中指定，你的CoreMod、Tweaker、Jar Metadata或litemod.json将指定模组Jar内的资源位置。</p><blockquote><p>配置路径被作为<em>资源</em>加载，因此可以放在Jar任何包中。重要的是，资源路径必须是相对的，<strong>不要</strong>在文件路径上预先准备一个主斜杠。</p><p>例如，如果您的配置文件在包<code>com.somepackage</code>中，则应该将配置文件的路径指定为<code>com/somepackage/myconfig.json</code>。</p></blockquote><p>每个<strong>配置</strong>定义一个<strong>Mixin集合</strong>，并且对于你的应用程序，可能会有多个<strong>Mixin集合</strong>。当你的Mixin针对不同的<em>环境</em>（见下文）时，只<em>需要</em>分离Mixin到不同集合中。然而有时也为了组织结构而将Mixin拆分到不同集合。</p><h3 id="Mixin配置文件"><a href="#Mixin配置文件" class="headerlink" title="Mixin配置文件"></a>Mixin配置文件</h3><p>除了定义<strong>Mixin集合</strong>之外，Mixin配置文件还定义了集合的附加属性。</p><p>首先，用四个键来定义集合本身：</p><ul><li><code>package</code>为这组Mixin定义了父包（这很重要，因为该包和所有子包在运行时都将被排除在<code>LaunchClassLoader</code>之外）。</li><li><code>mixins</code>为该配置定义了位于<em>父包</em>内的<em>Mixin“类”列表</em>，每个Mixin“类”都相对于<em>父包</em>指定，可以使用子包。此列表中的每一个条目都将应用于客户端和专用服务端（Dedicated Server）<a href="#note4"><sup>4</sup></a>侧。</li><li><code>client</code>定义了一组<strong>仅</strong>应用于<strong>客户端</strong>侧的Mixin。</li><li><code>server</code>定义了一组<strong>仅</strong>应用于<strong>专用服务端</strong>侧的Mixin。</li></ul><p>然后可以定义附加属性：</p><ul><li><code>refmap</code>定义该集合的<strong>引用映射（Reference Map）</strong>文件名（关于如何使用Mixin处理混淆之后再做更多讨论）。</li><li><code>priority</code>定义了这个Mixin集合相对于其他配置的<strong>优先级（Priority）</strong>。</li><li><code>plugin</code>是可选的用于Mixin配置的<strong>伴随插件</strong>的类名，该类可以在运行时以编程方式调整Mixin配置，参见<del>Mixin伴随插件</del>（尚未完成）。</li><li><code>required</code>定义了Mixin集合是否<strong>必须</strong>。当<em>required</em>标志应设为<code>true</code>时，如果单个Mixin未能应用，则应视为整个游戏处于失败状态。</li><li><code>minVersion</code>在当Mixin集合使用一些在特定版本添加的Mixin功能时设置。它可以省略当前版本不可用的Mixin集合。</li><li><code>setSourceFile</code>使Mixin处理器可以用Mixin类的源代码文件覆盖目标类中的<code>source file</code>属性。这在调试Mixin时很有用。</li><li><code>verbos</code>将所有<code>DEBUG</code>级别的日志消息等级调整为Mixin集合的<code>INFO</code>级。这也可以通过<code>mixin.debug.verbose</code><a href="https://github.com/SpongePowered/Mixin/wiki/Mixin-Java-System-Properties">系统属性</a>在全局范围内启用。</li></ul><p>需要注意的最重要的一点是，Mixin“类”必须位于一个包中，且其中没有你的项目的其他类（这包括Mixin主包的子包），因为启动时整个包将被排除在转换类加载器（Transforming Classloader）之外。</p><h3 id="游戏生命周期与你"><a href="#游戏生命周期与你" class="headerlink" title="游戏生命周期与你"></a>游戏生命周期与你</h3><p>为了理解Mixin如何与游戏底层交互，首先理解运行在<code>LaunchWrapper</code>中的游戏生命周期是至关重要的。</p><p><em>LaunchWrapper<a href="#note5"><sup>5</sup></a></em>接管了游戏的正常启动过程，以便允许<em>Tweaker</em><a href="#note6"><sup>6</sup></a>修改游戏。每个<em>Tweaker</em>可以提供<em>类转换器（Class Transformer）<a href="#note1"><sup>1</sup></a></em>，这能够在游戏类加载时修改它。<em>Tweaker</em>在命令行中指定，并由<code>Launch</code>类逐个加载并初始化，该类构成了<em>LaunchWrapper</em>启动逻辑的核心。</p><p>像FML和LiteLoader这样的<em>Tweaker</em>还能够加载和注入它们找到的其他<em>Tweaker</em>，因此<code>Launch</code>在循环中初始化<em>Tweaker</em>，直到不再继续注册更多的<em>Tweaker</em>。我们可以想到<code>Launch</code>中的执行流程如下：</p><p><img src="/2018/11/01/Introduction-to-Mixins-The-Mixin-Environment/mixin_env_0.png" alt="启动生命周期"></p><p>这个初始化阶段<em>必须</em>在游戏开始加载之前完成，这是绝对必要的，否则因为在<em>Tweak</em>初始化周期中晚点注册的<em>Transformer</em>可能没机会处理它需要的类，并且转换器链也可能不完整。</p><p>在初始化阶段发生的事情：</p><ul><li>像FML和LiteLoader这样的Tweaker寻找Mod，并且注入它们的转换器以及任何它们找到的额外的Tweaker。</li><li>FML的“Core Mod”（又叫载入时插件（Loading Plugin））被初始化并可以注册它们自己的转换器。</li></ul><p>由于Mixin子系统必须在这个早期阶段（在游戏类加载之前）初始化，所以它必须作为CoreMod或Tweaker加载，具体参阅下面的引导部分。</p><p><img src="/2018/11/01/Introduction-to-Mixins-The-Mixin-Environment/mixin_env_1.png" alt="启动生命周期"></p><p>一旦<em>Tweaker</em>初始化完成，<code>Launch</code>将调用游戏的原始<code>main()</code>方法，该方法启动游戏加载过程。在此之前，转换器链已经完成，因此转换器链可以通过注册的转换器加载和处理游戏类。游戏进入其主循环，按需加载类，并由转换器链（包括Mixin）处理。</p><p>上述内容中应该明白的是，游戏运行因此被分成两个截然不同的<em>阶段</em>，<em>Tweaker</em>在<strong>预初始化阶段（pre-init phase）</strong>被初始化，以及类似于正常的游戏生命周期的<strong>默认阶段（default phase）</strong>，该阶段可不在LaunchWrapper中运行。有必要了解这些阶段及其与Mixin子系统的关系。</p><h4 id="这只是我经历的一个阶段"><a href="#这只是我经历的一个阶段" class="headerlink" title="这只是我经历的一个阶段"></a>这只是我经历的一个阶段</h4><p>在通常情况下，我们的Mixin设置将只处理在<strong>默认</strong>阶段加载的类，并且事情非常简单。在这个阶段，我们已知：</p><ul><li>转换器链是完整的</li><li>游戏类能被安全地载入</li></ul><p>这意味着加载和转换游戏类字节码并应用Mixin是安全的，加载那些以便应用Mixin的必须的<em>类元数据</em>也是安全的（请记住，从上文开始，Mixin的验证和预转换在启动时一次性完成）。如果我们过早地生成元数据（例如，在预初始化之前的阶段），那么就有可能没有注册关键的转换器！这将导致Mixin字节码不完整或无效。</p><p><em>那么为什么要考虑<strong>预初始化</strong>呢？</em></p><p>答案很简单：<em>“那么我们可以融入到其他Tweaker提供的核心类中，特别是FML”</em></p><p>像<em>Sponge</em>这样的平台的要求之一是，有时必须以某种方式挂钩到底层平台，如果转换发生在<strong>Default</strong>阶段，核心类就已经加载（这已经超出了转换器的范围）。然而，正如我们知道的，在<strong>预初始化</strong>阶段加载与游戏相关的Mixin将不会起作用，因为需要的转换器不存在。</p><h4 id="关于环境"><a href="#关于环境" class="headerlink" title="关于环境"></a>关于环境</h4><p>然后，在Mixin处理器中，我们确实将处理过程分割为不同<em><strong>环境</strong></em>（每个阶段一个），然后你可以针对所期望应用的<em>环境</em>拆分你的Mixin集合。典型的Mixin应用情景的解决方式如下：</p><ul><li>一个只组合游戏类的Mixin集合应该在<strong>默认</strong>环境中注册</li><li>当需要在两个阶段应用Mixin时，两个Mixin集合（配置）应该将一个集合指定为<strong>预初始化</strong>Mixin，另一个集合则指定为<strong>默认</strong>Mixin。</li></ul><h4 id="跃跃欲试"><a href="#跃跃欲试" class="headerlink" title="跃跃欲试"></a>跃跃欲试</h4><p>值得注意的是，FML作为一个<em>Tweaker</em>加载它的CoreMod，并使用代理<em>Tweaker</em>将它们重新注入到启动生命周期中。因为我们对启动顺序可能有点微妙的感觉，因此值得注意的是，<em>“第一类（first-class）”</em>Tweaker<a href="#note7"><sup>7</sup></a>和CoreMod初始化期间产生的间接Tweaker有细微区别。</p><p>Mixin库内含一个第一类的Tweaker，它被设计为在尽可能早的时候注册并开始处理类，这在下图中标记为 <strong>(1)</strong> 。正常的CoreMod启动发生于 <strong>(2)</strong> 处的第一次循环，然后游戏加载开始于 <strong>(3)</strong>。</p><p><img src="/2018/11/01/Introduction-to-Mixins-The-Mixin-Environment/mixin_env_2.png" alt="启动生命周期"></p><p>如果需要在<strong>预初始化</strong>与类组合，则建议使用第一类Tweaker。</p><h3 id="使用FML-CoreMod引导Mixin"><a href="#使用FML-CoreMod引导Mixin" class="headerlink" title="使用FML CoreMod引导Mixin"></a>使用FML CoreMod引导Mixin</h3><blockquote><p><strong>注意：在生产环境中通过CoreMod引导Mixin目前是不可能的，要在发布版本中使用Mixin和Forge，你必须使用下述的调整方法。</strong>但是，你可能希望通过CoreMod在开发工作空间中加载Mixin，这可能实现，但它必须在生产环境中使用Tweaker：</p></blockquote><p>使用CoreMod在开发环境中引导Mixin：</p><ul><li>在你的CoreMod的构造函数中，使用以下代码初始化Mixin环境并设置Mixin配置文件的名称：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyCoreMod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 该语句必须最先出现，不含有该语句</span></span><br><span class="line">    <span class="comment">// 将导致一个运行时错误</span></span><br><span class="line">    MixinBootstrap.init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检索默认的Mixin环境和注册配置文件</span></span><br><span class="line">    MixinEnvironment.getDefaultEnvironment()</span><br><span class="line">        .addConfiguration(<span class="string">&quot;mixins.mymod.json&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过第一类Tweaker引导Mixin"><a href="#通过第一类Tweaker引导Mixin" class="headerlink" title="通过第一类Tweaker引导Mixin"></a>通过第一类Tweaker引导Mixin</h3><p>Mixin库内建有第一类<em>Tweaker</em>，你可以通过在Mod的Jar元数据中指定Tweaker类来使用。为此，只需像如下所示简单地指定Tweaker类名和你的Mixin配置文件名：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TweakClass: org.spongepowered.asm.launch.MixinTweaker</span><br><span class="line">TweakOrder: 0</span><br><span class="line">MixinConfigs: mixins.mymod.json</span><br></pre></td></tr></table></figure><br>TweakOrder值为<code>0</code>可确保尽可能早地注入Mixin转换器。</p><blockquote><p><strong>重要注意事项：</strong>FML环境中规定Tweaker通常不能是一个CoreMod。然而，为了克服这个限制，Mixin Tweaker从Jar Manifest文件中读取<code>FMLCorePlugin</code>条目，并通过反射将CoreMod类注入FML。</p></blockquote><p><code>MixinConfigs</code>值是一个以逗号分隔的配置文件列表，用于提供给Mixin子系统。</p><h3 id="使用LiteLoader引导Mixin"><a href="#使用LiteLoader引导Mixin" class="headerlink" title="使用LiteLoader引导Mixin"></a>使用LiteLoader引导Mixin</h3><p>Mixin子系统将自动地由LiteLoader引导。只需简单地将<code>mixinConfigs</code>键添加到你的<code>litemod.json</code>文件。<code>mixinConfigs</code>可以是以逗号分割的配置文件列表，也可以是作为字符串的常规JSON数组。</p><blockquote><p>译者注：</p><p><a name="note1"><sup>1</sup></a>转换器（Transformer）是指可修改类字节码达到修改类的目的的类。</p><p><a name="note2"><sup>2</sup></a>转换器链（Transformer Chain）是指一系列以链式结构组合的转换器。</p><p><a name="note3"><sup>3</sup></a>重映射转换器（Remapping Transformer）是指一种具有特殊功能的转换器，它可以对类名、方法名、字段名进行转换，常用于动态反混淆。</p><p><a name="note4"><sup>4</sup></a>专用服务端（Dedicated Server）是指仅具有服务器功能的应用程序，区别于客户端的内建服务端。例如MinecraftServer、Spigot等。</p><p><a name="note5"><sup>5</sup></a>LaunchWrapper是Minecraft用于接管游戏启动过程，更便利地修改游戏的启动包装器。</p><p><a name="note6"><sup>6</sup></a>Tweaker是LaunchWrapper用于配置、调整、修改游戏的接口，通常被各API实现。常见的实现有FML和LiteLoader。</p><p><a name="note7"><sup>7</sup></a>第一类（first-class）Tweaker是指在LaunchWrapper启动时便可加载的Tweaker，其类名由命令行参数直接指定，区别于由FML，LiteLoader等加载的间接Tweaker。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---The-Mixin-Environment&quot;&gt;Introduction to M</summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>介绍Mixin——理解Mixin的结构</title>
    <link href="https://mouse0w0.github.io/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/"/>
    <id>https://mouse0w0.github.io/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/</id>
    <published>2018-11-01T00:09:56.000Z</published>
    <updated>2025-05-20T11:48:56.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Understanding-Mixin-Architecture">Introduction to Mixins Understanding Mixin Architecture</a></p></blockquote><p>在开始开发Mixin之前，要使它们产生效果，最重要的是对其基本概念的理解。本文简要介绍了这些概念。尽管您可能熟悉这里所述的所有内容，但我建议至少略读前三个部分，因为它们介绍了我将用来演示如何使用Mixin的示例案例，以及Java和JVM中大量使用Mixin的一些特殊部分。</p><p><em><strong>这不是一篇教程</strong> 本介绍并非教程，有关Mixin实现的更多详细信息，请参阅Sponge仓库中的Mixin<a href="https://github.com/SpongePowered/SpongeCommon/tree/bleeding/src/example/java/org/spongepowered">示例代码</a>。</em></p><blockquote><p><strong>注意</strong></p><p>如果你已经全面了解了字节码、名称绑定，或直白的说你已经知道INVOKESPECIAL到INVOKEVIRTUAL，那么可以<a href="#4-只有你Mixin能拯救人类">跳到第四节</a>，这将介绍Mixin本身。</p></blockquote><h3 id="1-理解PortalMixin-以实例为例"><a href="#1-理解PortalMixin-以实例为例" class="headerlink" title="1. 理解PortalMixin - 以实例为例"></a>1. 理解<del>Portal</del>Mixin - 以实例为例</h3><p>为了能够想象Mixin是如何工作的，我将给出一个示例。 <em>注意，这个示例纯粹是为了演示而编写的，与真正的代码库中的名称完全不同！</em></p><p>在示例中，我们可以看到一个<code>EntityPlayer</code>类，它的直接（并且唯一）父类是<code>Entity</code>。我们可以用这样的UML风格来表示它：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_0.png" alt="图1 - 一个简单的类层次结构"></p><p><strong>图1 - 一个简单的（虚构的）类层次结构</strong></p><p>在Mixin术语中，<code>EntityPlayer</code>是<strong>目标类（Target Class）</strong>，Mixin将被应用于该类。</p><p>为了充实示例，让我们添加一些假想的字段和方法到想象的示例类中：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_1.png" alt="图二 - 一个有成员的简单的类层次结构"></p><p><strong>图二 - 一个有假想字段和方法的简单的类层次结构</strong></p><p>选择这种表示方法是为了凸出哪些成员在类的公开区域，其中公共方法和字段将凸出在类主体之外，因为它们对其他对象是可见的。在使用Mixin时，外界是我们必须记住的一个重要概念。</p><p>注意，继承自<code>Entity</code>的公共方法<em>也</em>是类公共可见区域的一部分，而从父类继承的“幽灵”方法<code>getHealth</code>和<code>setHealth</code>也存在与类的整体外观中。</p><p>在使用Mixin之前，深入了解<code>this</code>和<code>super</code>这两个Java关键字是非常重要的。这似乎很奇怪，因为任何使用Java超过五分钟的人都会认识这些关键词及其用法，但如果你不想在编写Mixin时抓狂，那么充分理解这两个词的微小差异是至关重要的。</p><p>首先来看一下我们假想类中的一些可能的调用和访问：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_2.png" alt="图3 - 一些字段和方法的访问"></p><p><strong>图3 - 一些字段和方法的访问</strong></p><p>对于该情况，<code>this.level</code>、<code>this.update()</code>和<code>this.food</code>似乎没什么有争议的，它们看起来都很标准。此外，调用<code>super.health</code>和<code>this.health</code>，以及从<code>update</code>调用<code>super.onUpdate()</code>的目的是为了凸出JVM的一个方面，它在编写Java代码时并不明显。</p><p>问一下自己下述问题：</p><ul><li><p>用<code>super</code>来限定<code>onUpdate</code>的调用有什么实际意义，为什么不用<code>this</code>？</p></li><li><p>用<code>super</code>来限定<code>health</code>的调用有什么实际意义，为什么不用<code>this</code>？</p></li></ul><p>毕竟这两种限制在实际中都一样，对吧？</p><p>上述两个问题的答案如下：</p><ul><li><p><code>super.onUpdate()</code> <em>将始终调用</em><code>Entity</code><em>中的方法，即使子类重写它</em>，而<code>this.onUpdate()</code>将<em>调用子类中重写的方法</em>。</p></li><li><p>没有区别，<code>Entity</code>中的字段始终从方法<code>takeDamage</code>访问，即使子类通过再次声明来“隐藏”字段。</p></li></ul><p>这种行为的根本原因是，用<code>super</code>限定的调用和所有字段访问在编译时被<strong>静态绑定（Statically Bound）</strong>，这意味着它们总是引用成员。相反，用<code>this</code>限定的访问都是<strong>动态绑定（Dynamically Bound）</strong>，这意味着它们直到实际调用时才解析它们的目标，从而允许子类重写方法并在适当的时候调用它们。</p><blockquote><p><strong>注意</strong></p><p>除了<code>super</code>限定的调用，访问<code>private</code>和<code>static</code>方法也总是<strong>静态绑定</strong>。</p><p>在字节码中，静态绑定调用是以INVOKESPECIAL和INVOKESTATIC操作符来表示，而动态调用是以INVOKEVIRTUAL操作符来表示。</p></blockquote><p>在开发Mixin时，准确意识到这些关键字的性质是有用的，这也是对Mixin类施加的一些限制的原因，稍后对此进行更多的说明。</p><h3 id="2-透镜窥秘"><a href="#2-透镜窥秘" class="headerlink" title="2. 透镜窥秘"></a>2. 透镜窥秘</h3><p>我在上述描述中避免使用<em>接口</em>来描述公开可见的成员，以避免与<em>实际的</em>接口混淆，因为接口本身在使用Mixin时起着关键的作用。</p><p>为了理解接口如何影响我们与类的交互，让我们看看在例子中创建一个包含一些方法的接口，让后通过接口访问这些方法会发生什么。</p><p>旁注：<em>是的，这完全偏离了UML的轨道，但UML对于表示此处的概念并不真的有用，这个框图的<strong>底部</strong>从其他任何对象来看都是“可视区域”，该接口实际上位于公共类“之前”，并给出它的一个子集。</em></p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_3.png" alt="图4 - 一个让UML爱好者讨厌的图"></p><p><strong>图4 - 一个让UML爱好者讨厌的图</strong></p><p>这里有一些有用的东西值得注意：</p><ul><li><p>首先，必须注意到<code>Entity</code>类中的<code>getHealth</code>和<code>setHealth</code>方法实际上正在实现接口方法，即使<code>Entity</code>类不了解<code>LivingThing</code>接口，这意味着接口方法中没有任何<em>特殊</em>：只要方法签名<a href="#nb1"><sup>1</sup></a>与接口中的签名匹配，就认为类方法实现了接口方法。从这里可以清楚地看出接口方法调用是<strong>动态绑定</strong>。</p></li><li><p>我们也没有修改两个类，除了声明它<code>implements LivingThing</code>。事实上，如果Java不要求我们包含<code>implements</code>子句，那么这个程序结构是合法的，对程序没有任何改变。这告诉我们，如果能够以某种方式偷偷地将<code>implements</code>子句插入到目标类中，那么只要接口的方法存在，我们就能在目标类上调用它们。</p></li></ul><blockquote><p><a name="nb1"><sup>1</sup></a> 一个方法的<strong>签名</strong>是它的一组参数<em>及其返回类型</em>。例如下述方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ThingType <span class="title function_">getThingAtLocation</span><span class="params">(<span class="type">double</span> scale, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z, <span class="type">boolean</span> squash)</span> &#123;</span><br></pre></td></tr></table></figure><br>它的签名将会是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(double,int,int,int,boolean)com.mypackage.ThingType</span><br></pre></td></tr></table></figure><br>注意，我们将参数放在括号中，最后是返回类型。在实际中，为了节省空间，将会<a href="https://www.murrayc.com/permalink/1998/03/13/the-java-class-file-format/#TypeDescriptors">使用更紧凑的语法</a>，在字节码中，上述签名是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(DIIIZ)Lcom/mypackage/ThingType;</span><br></pre></td></tr></table></figure><br>如果你打算使用<em>Injector</em>，你需要熟悉字节码描述符。</p></blockquote><h3 id="3-嘎嘎"><a href="#3-嘎嘎" class="headerlink" title="3. 嘎嘎"></a>3. 嘎嘎</h3><p>我们正在慢慢组装的拼图的最后一块是一个与接口有关的实用的Java语言特性，即你可以将任何对象引用转换为任何接口，编译器很乐意编译它。</p><p>例如，假设我们为可以升级的对象创建一个新的接口，叫做<code>Leveller</code>，就像这样：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_4.png" alt="图5 - Leveller接口"></p><p><strong>图5 - <em>多么美好的一天啊，嘿嘿</em></strong></p><p>下述代码将愉快地编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的EntityPlayer</span></span><br><span class="line">    <span class="type">EntityPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EntityPlayer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这将被编译，即使EntityPlayer没有</span></span><br><span class="line">    <span class="comment">// 实际上实现接口，但它在运行时</span></span><br><span class="line">    <span class="comment">// 会抛出一个ClassCastException</span></span><br><span class="line">    <span class="type">Leveller</span> <span class="variable">lev</span> <span class="operator">=</span> (Leveller)player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们永远不会到达这个代码，但它也将编译好。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> lev.getLevel();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>上节中我们知道，<code>EntityPlayer</code>的方法<code>getLevel()</code><strong>能</strong>愉快地在不改变类的情况下实现接口，但<code>implements</code>子句没有显式声明接口这一事实导致在运行时转换失败。如果我们可以在运行时以某种方式添加<code>implements</code>字句，那么最终有一种可行的方法以使用接口在Java中实现<em>鸭子类型（Duck typing）</em>。</p><blockquote><p>“实现什么？”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 可能是你说的</p></blockquote><p><a href="http://en.wikipedia.org/wiki/Duck_typing">鸭子类型（Duck typing）</a>是一种在动态类型化语言中使用的隐式类型化方法，它允许基于对象的成员是否存在来访问或调用对象的成员。它的名字来自“鸭子测试（Duck test）”，表达如下：</p><blockquote><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p></blockquote><p>换句话说，如果我们只关心一个对象有方法<code>quack()</code>和<code>walk()</code>，那么对我们而言，它是一个<code>Duck</code>，而不关心它是否只是一个非常聪明的<code>Pigeon</code>，只要它有这些方法，那它对我们来说就是<code>Duck</code>。</p><p>如果还不清楚这里说了什么，那么我建议<a href="http://en.wikipedia.org/wiki/Duck_typing">阅读Wikipedia的条目</a>，因为它详细地涵盖了超出本介绍范围的概念。</p><p>那么到目前为止我们知道了什么？</p><ul><li><p>我们知道类和接口之间的关系非常脆弱，只需稍加修改就可以以多种方式做对我们有利的事情。</p></li><li><p>我们知道可以利用Java中的<strong>动态绑定</strong>编写能通过编译的代码（即使它不能运行），并以某种方式将<code>implements</code>子句添加到目标对象上是这项工作的关键。</p></li><li><p>我们知道在编译时，使用<code>super</code>关键字的父类调用是<strong>静态绑定</strong>，这意味着在指定<code>super</code>时，我们需要额外考虑，我们指定的是<em>什么</em>。</p></li></ul><p>最后要考虑的是，当类<em>不</em>实现接口时会发生什么。让我们把另一个名为<code>setLevel()</code>的方法添加到我们的示例接口<code>Leveller</code>中：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_5.png" alt="图6 - 添加setLevel()"></p><p><strong>图6 - 添加setLevel()</strong></p><p>将第二个方法添加到接口中会增加另一个 - 不同的 - 运行时错误，在本例中为<code>AbstractMethodError</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">EntityPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EntityPlayer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设我们可以运行时将接口声明添加到EntityPlayer类，允许这个操作成功。</span></span><br><span class="line">    <span class="type">Leveller</span> <span class="variable">lev</span> <span class="operator">=</span> (Leveller)player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该语句会在运行时抛出AbstractMethodError，</span></span><br><span class="line">    <span class="comment">// 因为setLevel(I)在EntityPlayer及其任何父类中都没有定义。</span></span><br><span class="line">    lev.setLevel(<span class="number">10</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>理解了Java和JVM的这些方面，让我们来看看Mixin它自己。</p><h3 id="4-只有你Mixin能拯救人类"><a href="#4-只有你Mixin能拯救人类" class="headerlink" title="4. 只有你Mixin能拯救人类"></a>4. 只有<del>你</del>Mixin能拯救人类</h3><p>那么现在我们知道Mixin必须完成的基本任务，以便使我们可以使其他的对象嘎嘎：</p><ol><li>让我们在运行时将我们所选的接口应用到<strong>目标类</strong></li><li>让我们为接口中声明但<strong>目标类</strong>中不存在的任何方法插入一个方法<em>实现</em></li></ol><p>首先让我们看看如何声明一个Mixin类，以<code>EntityPlayer</code>作为它的<strong>目标类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(EntityPlayer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinEntityPlayer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，就是这么简单。使用<code>@Mixin</code>注解将这个类定义为一个Mixin类，并指定我们想应用它的<strong>目标类</strong>。但要注意：</p><ul><li><p>Mixin类使用<code>abstract</code>修饰符标记。虽然这不是必须的，但当在IDE中使用Mixin时它会很有用，因为它意味着终端用户不能编写试图实例化Mixin类的代码，这会在运行时导致错误。它还避免了必须实现任何声明的接口中的每一个方法的要求（Java编译器强加的），这是Mixin的主要目的之一。</p></li><li><p>Mixin类继承了<code>Entity</code>，这是与我们的<strong>目标类</strong>相同的超类。这是很重要的，用以保持任何<strong>静态编译</strong>的语义编译到我们的Mixin类中。稍后再详细说明。</p></li></ul><p>如果我们现在在运行时包含这个Mixin并运行游戏，那么将应用Mixin但绝对不会更改任何内容，这是因为我们实际上没有在Mixin中声明任何内容。让我们来看看如何实现上述目标<strong>1</strong>，并使用Mixin在<strong>目标类</strong>上添加新接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(EntityPlayer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinEntityPlayer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Entity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">LivingThing</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样！当Mixin被处理时，在Mixin上声明的任何接口都被应用到<strong>目标类</strong>。让我们看看当前的类层次结构：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_6.png" alt="图7 - Mixin层次结构（应用前）"></p><p><strong>图7 - Mixin层次结构（应用前）</strong></p><p>虽然这个图代表了我们将创建的类的实际层次结构，但它实际上更用于（并且在一些更复杂的情况下，至关重要）<em>认识到Mixin<strong>不是真正的类</strong>。</em>在运行时，Mixin将被应用到<strong>目标类</strong>，因此，认为Mixin<em>存在于<strong>目标类内</strong></em>反而更有利于良好的思考过程。</p><p>在Mixin应用之后，新的类层次看起来像这样：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_7.png" alt="图8 - 类层次结构（应用后）"></p><p><strong>图8 - 类层次结构（应用后）</strong></p><p>如你所见，目标类现在实现了<code>LivingThing</code>接口，现在允许我们的鸭子类型按所想那样使用了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">EntityPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EntityPlayer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用了Mixin之后，转换成功</span></span><br><span class="line">    <span class="type">LivingThing</span> <span class="variable">living</span> <span class="operator">=</span> (LivingThing)player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为转换成功了，所以我们可以传递对象</span></span><br><span class="line">    <span class="comment">// 到其他需要应用LivingThing的地方</span></span><br><span class="line">    <span class="comment">// 如下所示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive(living)) &#123;</span><br><span class="line">        <span class="comment">// 万岁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(LivingThing living)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们现在可以很好地调用getHealth()方法，因为该方法</span></span><br><span class="line">    <span class="comment">// 存在并可通过LivingThing接口访问</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">health</span> <span class="operator">=</span> living.getHealth();</span><br><span class="line">    <span class="keyword">return</span> health &gt; <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>由于我们已经实现了第一个目标，现在可以成功地向<strong>目标类</strong>应用新的接口，因此让我们来看看第二个目标：</p><ul><li>让我们为接口中声明但<strong>目标类</strong>中不存在的任何方法插入一个方法<em>实现</em></li></ul><p>我们首先让我们的Mixin类实现<code>Leveller</code>接口，该接口声明当前未在我们的<strong>目标类</strong>及其任何父类中实现方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(EntityPlayer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinEntityPlayer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Entity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">LivingThing</span>, Leveller &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>生成以下类层次：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_8.png" alt="图9 - Mixin类层次（应用前）"></p><p><strong>图9 - Mixin类层次（应用前）</strong></p><p>因为我们的Mixin类是<code>abstract</code>，该代码将很好地通过编译，但是在运行时任何对<code>setLevel()</code>方法的调用都会抛出如上所述的<code>AbstractMethodError</code>。我们可以在Mixin自身中定义<code>setLevel()</code>方法来解决这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(EntityPlayer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinEntityPlayer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Entity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">LivingThing</span>, Leveller &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> newLevel)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 实现该方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_9.png" alt="图10 - 添加一个方法到Mixin"></p><p><strong>图10 - 添加一个方法到Mixin</strong></p><p>现在，当应用Mixin时，新方法也将被添加到<strong>目标类</strong>：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_10.png" alt="图11 - 类层次结构（应用后）"></p><p><strong>图11 - 类层次结构（应用后）</strong></p><p>我们修改的目标类现在完全实现了所有声明的接口，我们可以看到想目标类添加新方法是多么容易。但目前我们的新方法实际上没有做任何事情，我们将在下一节中看到如何修复。</p><h3 id="5-点燃蜡烛将投下Shadow"><a href="#5-点燃蜡烛将投下Shadow" class="headerlink" title="5. 点燃蜡烛将投下Shadow"></a>5. 点燃蜡烛将投下Shadow</h3><p>因此，现在我们有办法将新方法注入<strong>目标类</strong>，但是在实现新注入的方法体时，我们就很快遇到一个问题：在理想情况下，我们希望新的<code>setLevel()</code>实现能够访问<code>EntityPlayer</code>中的<code>level</code>变量。但有一个问题是……它不能。</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_11.png" alt="图12 - 不可能的访问"></p><p><strong>图12 - 不可能的访问</strong></p><p>我们不能访问<strong>目标类</strong>的成员，因为在实际应用Mixin之前，字段不存在！因为Mixin类的父类是<code>Entity</code>，如果字段是<code>protected</code>，它甚至没用：对Java编译器而言，字段是不可视的。</p><p>但<strong>我们知道</strong>当Mixin被应用时，字段<strong>将在那里</strong>，我们需要的是一种方法告诉Java<em>“嘿，这个字段<strong>将</strong>会存在，让我访问它”</em>。幸运的是，Mixin提供了一个机制，通过<code>@Shadow</code>注释做到这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(EntityPlayer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinEntityPlayer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Entity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">LivingThing</span>, Leveller &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Shadow</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> newLevel)</span> &#123;</span><br><span class="line">        <span class="comment">// 引用上面的影子字段，但将引用</span></span><br><span class="line">        <span class="comment">// 应用Mixin后的真正的字段</span></span><br><span class="line">        <span class="built_in">this</span>.level = newLevel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Shadow</code>注释在Mixin中创建一个“虚拟字段”，它反映了<strong>目标类</strong>的对应部分：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_12.png" alt="图13 - 我和我的影子"></p><p><strong>图13 - 我和我的影子</strong></p><p>还可以将<code>@Shadow</code>使用在方法上，一遍调用只在目标类中定义的方法，例如，在设置等级后立刻调用<code>update()</code>方法，我们可以轻松的影射方法，然后从新的<code>setLevel()</code>方法体中调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mixin(EntityPlayer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MixinEntityPlayer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Entity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">LivingThing</span>, Leveller &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Shadow</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Shadow</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> newLevel)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置等级的值</span></span><br><span class="line">        <span class="built_in">this</span>.level = newLevel;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用影射的方法以更新实体状态</span></span><br><span class="line">        <span class="built_in">this</span>.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常将影子方法声明为<code>abstract</code>，只是为了避免编写方法体，但很显然，我们不可能将<code>private</code>与<code>abstract</code>同时声明，所以我们只是用空方法体声明影子方法。</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_13.png" alt="图14 - 影射万物"></p><p><strong>图14 - 影射万物</strong></p><h3 id="6-它是鸟吗？是飞机吗？不，它是父类！"><a href="#6-它是鸟吗？是飞机吗？不，它是父类！" class="headerlink" title="6. 它是鸟吗？是飞机吗？不，它是父类！"></a>6. 它是鸟吗？是飞机吗？不，它是父类！</h3><p>旅途的最后一站是关于Mixin的基本特性，简要介绍如何在Mixin中处理父类的访问。首先，我们需要理解为什么一个Mixin类被声明为与<strong>目标类</strong>相同的超类。</p><p>首先让我们快看看当前的类层次结构：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_14.png" alt="图15 - 游戏状态"></p><p><strong>图15 - 游戏状态</strong></p><p>请记住，从第一节开始使用<code>super</code>关键字的调用都是<strong>静态绑定</strong>的。在我们的Mixin类上下文中，如果我们如<strong>图15</strong>所示调用<code>super.onUpdate()</code>，那么生成的字节码将具体地引用<code>Entity</code>类中的<code>onUpdate</code>方法。</p><p>当Mixin与<strong>目标类</strong>具有相同的父类时，这正是我们想要的。然而，实际上Mixin可以继承<em>目标类层次结构上的任何类</em>，直到并包括<code>Object</code>。</p><p>让我们假设一下，<code>EntityPlayer</code>不是直接从<code>Entity</code>继承的，而是从中间的一个类<code>EntityMoving</code>，而Mixin类仍然可以直接继承<code>Entity</code>：</p><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_15.png" alt="图16 - 继承层次结构 - 注意：此图是故意错误的！"></p><p><strong>图16 - 继承层次结构 - 注意：此图是故意错误的！</strong></p><p>看看这个新的层次结构，现在很明显为什么<code>super.onUpdate()</code>将<em>出现</em>在Mixin类中调用<code>Entity</code>的方法，但这里很重要的一点是，<strong>忽略IDE（可能还有常识）告诉你的，并记住Mixin的关注点永远在 <em>目标类</em></strong>！</p><p>这里的问题是，中间类<code>EntityMoving</code>已经重写了<code>onUpdate</code>，并且类的功能范围使得在超类中调用<code>onUpdate</code>实际上会导致不一样的行为。当我们在Mixin中调用<code>super.onUpdate()</code>时，它<strong>必须</strong>具有<strong>相同</strong>的语义，就像<strong>从目标类</strong>调用同一个Java语句一样，并且<strong>确实如此</strong>。</p><ul><li><p>为了保持你键入到Mixin中的Java代码的语义一致性，Mixin转换器在应用时更新Mixin类中所有的<strong>静态绑定</strong>。这意味着在上述例子中，调用<code>super.onUpdate()</code>将正确地调用<code>EntityMoving</code>中的方法。</p></li><li><p>这并不影响<code>this</code>关键词的语义。对于<code>protected</code>和<code>public</code>方法，它们总是使用<strong>动态绑定</strong>，因此总是调用适当的子类方法。</p></li></ul><blockquote><p>为了实现该技术，转换器将处理Mixin中所有的INVOKESPECIAL操作符，并分析目标类的父类层次结构，以找到该方法的最特化的版本。该过程开销很高，并且只在“分离的”Mixin（那些父类与目标类的父类不同的Mixin）上执行。为了避免这种处理步骤，建议尽可能地将Mixin类与它们的目标类具有相同的父类。</p></blockquote><p><img src="/2018/11/01/Introduction-to-Mixins-Understanding-Mixin-Architecture/mixin_tut_16.png" alt="图17 - 最终层次结构"></p><p><strong>图17 - 最终层次结构（Mixin应用后）</strong></p><p>如你所见，将Mixin应用到目标类之后，将<code>super.onUpdate()</code>调用的语言更新为与<strong>目标类</strong>一致，并且一切都再次工作良好。</p><h3 id="7-圆满完成"><a href="#7-圆满完成" class="headerlink" title="7. 圆满完成"></a>7. 圆满完成</h3><p>虽然本介绍涵盖了Mixin的基本知识，但是还有很多方面需要探讨，尤其是在<strong>目标类</strong>在使用之前会被混淆的生产环境中工作时。</p><h4 id="更多Mixin文章（即将到来）"><a href="#更多Mixin文章（即将到来）" class="headerlink" title="更多Mixin文章（即将到来）"></a>更多Mixin文章（即将到来）</h4><ul><li><a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---The-Mixin-Environment">Introduction to Mixins - The Mixin Environment</a></li><li><a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Overwriting-Methods">Introduction to Mixins - Overwriting Methods</a></li><li><a href="https://github.com/SpongePowered/Mixin/wiki/Resolving-Method-Signature-Conflicts">Resolving Method Signature Conflicts</a></li><li><a href="https://github.com/SpongePowered/Mixin/wiki/Obfuscation-and-Mixins">Obfuscation and Mixins</a></li><li><a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Soft-Implementation">Advanced Mixin Usage - Soft Implementation</a></li><li><a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Using-Injection">Advanced Mixin Usage - Using Injection</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Understanding-Mixin-Architecture&quot;&gt;Introd</summary>
      
    
    
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/categories/Mixin/"/>
    
    
    <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
    <category term="Bytecode" scheme="https://mouse0w0.github.io/tags/Bytecode/"/>
    
    <category term="Mixin" scheme="https://mouse0w0.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>以贝塞尔曲线渲染一个SVG椭圆弧</title>
    <link href="https://mouse0w0.github.io/2018/10/28/Rendering-an-SVG-elliptical-arc-as-bezier-curves/"/>
    <id>https://mouse0w0.github.io/2018/10/28/Rendering-an-SVG-elliptical-arc-as-bezier-curves/</id>
    <published>2018-10-28T15:09:46.000Z</published>
    <updated>2025-05-20T11:48:56.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/">https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/</a></p></blockquote><p>我需要绘制椭圆和圆弧，如果没有它们就不能完成一个向量API。但苹果的核心图形库除了轴对齐圆弧外没有其他的东西。安卓有椭圆，但似乎也限制它轴对齐。这意味着我要将椭圆转换成一组贝塞尔曲线，用于这些后端API。</p><blockquote><p>在本文中，另请参阅<a href="https://mortoray.com/2017/02/02/the-smooth-sexy-curves-of-a-bezier-spline/">The smooth sexy curves of a bezier spline (平滑性感的贝塞尔曲线)</a>和<a href="https://mortoray.com/2017/02/23/stuffing-curves-into-boxes-calculating-the-bounds/">Stuffing curves into boxes: calculating the bounds (让方框囊括曲线：计算边界)</a>。</p></blockquote><h2 id="SVG圆弧表示法"><a href="#SVG圆弧表示法" class="headerlink" title="SVG圆弧表示法"></a>SVG圆弧表示法</h2><p>SVG的圆弧指令允许绘制任何一种想要的弧形。由于<a href="https://www.fusetools.com/">Fuse</a>的旧<code>Path</code>已经允许SVG路径数据，所以使用这个弧线的定义似乎是合理的。</p><p>SVG通过通过它们的端点定义弧：在哪里开始和结束。这些再与椭圆的半径和旋转组合。基于以上参数，就有四个可能的弧。然后还要囊括两个奇怪的标志来选择对应弧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a radius-x radius-y x-axis-rotation large-arc-flag sweep-flag x y</span><br></pre></td></tr></table></figure><p>这是从绘图角度指定弧的一种好方法。你知道两点相连，你也知道你想要哪个扫掠角。但问题是，这不是一个实际绘制弧线的好办法。它需要转换为一个中心点和要绘制的角度范围。</p><h2 id="端点转换到中心点"><a href="#端点转换到中心点" class="headerlink" title="端点转换到中心点"></a>端点转换到中心点</h2><p>SVG附录“椭圆弧实现注释”中有一个“从端点到中心点的参数化转换”算法。这很有帮助，因为该圆弧标记法有些不常见，很难在别处找到这个算法。</p><p>然而，它也有一些问题。标准中的示例弧实际上错了！它需要修复一下。</p><h3 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h3><p>首个问题就是F6.5.2(下图公式)中的平方根：</p><p><img src="/2018/10/28/Rendering-an-SVG-elliptical-arc-as-bezier-curves/svg_f-6-5-2.png" alt="svg_f-6-5-2"></p><p>当试图开方一个负数时，会产生一个虚数，它会变成$NaN$。每当输入的半径不够大，两个端点与椭圆链接时，就会出现这种问题。即使原数是一致的，浮点精度误差也会导致这个值略负。这对开方来说是不可忽略的：<code>sqrt(0)</code>是$0$，但<code>sqrt(-0.000001)</code>是$NaN$。</p><p>我对它的修复如下。从规范中我们分离出$\sqrt{pq}$如下所示：</p><script type="math/tex; mode=display">\begin{array}{rll} dq &= r_x^2 y_1'^2 + r_y^2 x_1'^2 \\ \\ pq &= \frac{r_x^2 r_y^2 - dq}{dq} \\ \end{array}</script><p>问题是当所给的$cr &gt; 1$时，$pq &lt; 0$：</p><script type="math/tex; mode=display">\begin{array}{rll} cr &= dq : (r_x^2 r_y^2) \\ \\ cr &= \frac{x_1'^2}{r_x^2} + \frac{y_1'^2}{r_y^2} \end{array}</script><p>考虑到这个系数，很容易地扩大半径。我们将半径乘以$\sqrt{cr}$。这将准确地将$cr$值减少到1（尽管如此，仍需要注意浮点精度问题），导致$pq == 0$。</p><blockquote><p>完全方程在本文的末尾。我将执行<code>sqrt(max(0, pq))</code>；由于精确性，在放大r之后，pq值仍可能为负（实际上在使用中，出现了轻微的负值）。</p></blockquote><h3 id="反余弦"><a href="#反余弦" class="headerlink" title="反余弦"></a>反余弦</h3><p>该算法还包括计算两个矢量之间的夹角。虽然已经有了计算的函数，但我还是决定使用他们的方程来确保$±$部分能够按预期工作。</p><p><img src="/2018/10/28/Rendering-an-SVG-elliptical-arc-as-bezier-curves/svg_f-6-5-4.png" alt="svg_f-6-5-4"></p><p>通常情况下，我们需要担心这里的除法，但这个算法中的预过滤确保我们有非零的长度。</p><p>但它不能保证<code>arccos</code>的参数是有效的。由于浮点精度（又是它），该值可能略大于1，或略小于1。这对于<code>arccos</code>是不可忽视的，这在那些情况下仅返回一个<code>NaN</code>（准确地说结果是一个虚数）。在我的代码中，我添加了一个<code>clamp</code>方法来防止它。</p><p><code>clamp</code>是有效的，因为理论上，方程不能产生范围在-1~1之外的值。这是一个测定过的角度，它有固定的数值范围。我得到的超出范围的值也只是略微超出范围而已。</p><h2 id="从弧到贝塞尔曲线"><a href="#从弧到贝塞尔曲线" class="headerlink" title="从弧到贝塞尔曲线"></a>从弧到贝塞尔曲线</h2><p>我们可以使用这个中心点表示法把圆弧转换为一组贝塞尔曲线。这涉及到很多东西：椭圆的参数方程，它的倒数，以及一些我没有导出的复杂公式。</p><p>值得庆幸的是，L. Maisonobe发表了一篇<a href="http://www.spaceroots.org/documents/ellipse/elliptical-arc.pdf">Drawing an elliptical arc using polylines, quadratic or cubic Bézier curves（使用折线、二次或三次贝塞尔曲线绘制椭圆弧）</a>的论文。我所要做的就是读它并翻译成代码。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>首先是获得椭圆的参数方程。椭圆的标准方程如下：</p><script type="math/tex; mode=display">\left(\frac{x}{a}\right)^2 + \left(\frac{y}{b}\right)^2 = 1</script><p>这告诉我们，给定的<code>x, y</code>点是否位于椭圆上。但这对绘制椭圆不是很有用。取而代之的是，我们想要得到一个参数化的形式。下面是一个函数，传递一个值<code>t</code>，这表示椭圆上的一个伪角度，然后返回<code>x, y</code>坐标。这其中包括椭圆半径与X轴的转角（SVG弧必须的）。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> float2 <span class="title">EllipticArcPoint</span>(<span class="params"> float2 c, float2 r, <span class="built_in">float</span> xAngle, <span class="built_in">float</span> t </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> float2(</span><br><span class="line">        c.X + r.X * Math.Cos(xAngle) * Math.Cos(t) - r.Y * Math.Sin(xAngle) * Math.Sin(t),</span><br><span class="line">        c.Y + r.X * Math.Sin(xAngle) * Math.Cos(t) + r.Y * Math.Cos(xAngle) * Math.Sin(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我提到<code>t</code>是一个伪夹角，它不是一个真正的“角度”。它的角度是基于“如果一个人认为椭圆是一个被拉伸然后旋转的圆”（这是SVG规范中的用词）。</p><p>这个方程式的目的是，我们可以在圆弧定义的起始角和终止角之间迭代，以找到椭圆上的点。第二个函数叫做椭圆弧导数。这两个函数让我们计算一个近似于任何弧线的贝塞尔曲线。下表是我们所需的。</p><p><img src="/2018/10/28/Rendering-an-SVG-elliptical-arc-as-bezier-curves/maisonobe_3-4-1.png" alt="maisonobe_3-4-1"></p><p>其中$\mathit{E}$是椭圆弧点函数，$\mathit{E}’$是椭圆弧导数函数，$\eta_1$和$\eta_2$是我们正在近似计算的弧的起始角和结束角。</p><p>我所要做的就是把角度范围细分成小节以获得良好的近似值。我不太理解这篇论文的误差计算，但是我发现<a href="https://www.joecridge.me/content/pdf/bezier-arcs.pdf">Joe Cridge的另一篇论文</a>指出$\pi/2$的分割方式在相当高分辨率的设备上有潜在的一个像素误差。因此，我选择了$\pi/4$来保证平滑，即使是在高像素密度的移动设备上。</p><h2 id="一个椭圆"><a href="#一个椭圆" class="headerlink" title="一个椭圆"></a>一个椭圆</h2><p><img src="/2018/10/28/Rendering-an-SVG-elliptical-arc-as-bezier-curves/arc_svg_example.png" alt="arc_svg_example"></p><p>把之前的一切组合在一起，我们就能够从SVG渲染示例了。这是建立在向量API上的，我从上一篇文章开始，对<a href="https://mortoray.com/2017/02/02/the-smooth-sexy-curves-of-a-bezier-spline/">平滑性感的贝塞尔曲线</a>进行了研究。我的工作后端是苹果核心图形，但这个代码也将运行在安卓Canvas和Windows的System.Drawing上。通过自己计算贝塞尔曲线，我们不需要限制后端绘制弧的能力了。</p><p>本系列还有一篇文章即将面世。我们仍然需要计算这些图形的边界。这是衍生的另一件奇遇。</p><blockquote><p>我在<a href="https://www.fusetools.com/">Fuse</a>上的作品充满了有趣的代码。关注我的<a href="http://twitter.com/edaqa">Twitter</a>或者<a href="https://www.facebook.com/mortoray/">Facebook</a>以获得更多的见解和轶事。如果有什么特别的跨平台工具激起你的好奇心，<a href="https://mortoray.com/about/?src=fuse">请让我知道</a>。</p></blockquote><h2 id="附录：端点到中心弧转换"><a href="#附录：端点到中心弧转换" class="headerlink" title="附录：端点到中心弧转换"></a>附录：端点到中心弧转换</h2><p>这是Uno代码（和本文发布时间一样）用于从SVG弧转换为中心点表示法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行SVG 1.1 规范中详细说明的点到弧中心点参数的转换。</span></span><br><span class="line"><span class="comment">    F.6.5 从端点到中心点参数化转换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @param r 必须是一个ref，以防它需要按SVG规范放大。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EndpointToCenterArcParams</span>(<span class="params"> float2 p1, float2 p2, <span class="keyword">ref</span> float2 r_, <span class="built_in">float</span> xAngle, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">bool</span> flagA, <span class="built_in">bool</span> flagS, <span class="keyword">out</span> float2 c, <span class="keyword">out</span> float2 angles </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> rX = Math.Abs(r_.X);</span><br><span class="line">    <span class="built_in">double</span> rY = Math.Abs(r_.Y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(F.6.5.1)</span></span><br><span class="line">    <span class="built_in">double</span> dx2 = (p1.X - p2.X) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="built_in">double</span> dy2 = (p1.Y - p2.Y) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="built_in">double</span> x1p = Math.Cos(xAngle)*dx2 + Math.Sin(xAngle)*dy2;</span><br><span class="line">    <span class="built_in">double</span> y1p = -Math.Sin(xAngle)*dx2 + Math.Cos(xAngle)*dy2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(F.6.5.2)</span></span><br><span class="line">    <span class="built_in">double</span> rxs = rX * rX;</span><br><span class="line">    <span class="built_in">double</span> rys = rY * rY;</span><br><span class="line">    <span class="built_in">double</span> x1ps = x1p * x1p;</span><br><span class="line">    <span class="built_in">double</span> y1ps = y1p * y1p;</span><br><span class="line">    <span class="comment">// 当 `dq &gt; rxs * rys` (见下文)，检查半径是否太小 `pq &lt; 0`</span></span><br><span class="line">    <span class="comment">// cr 是比率 (dq : rxs * rys) </span></span><br><span class="line">    <span class="built_in">double</span> cr = x1ps/rxs + y1ps/rys;</span><br><span class="line">    <span class="keyword">if</span> (cr &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//缩放 rX,rY 同时 cr == 1</span></span><br><span class="line">        <span class="keyword">var</span> s = Math.Sqrt(cr);</span><br><span class="line">        rX = s * rX;</span><br><span class="line">        rY = s * rY;</span><br><span class="line">        rxs = rX * rX;</span><br><span class="line">        rys = rY * rY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">double</span> dq = (rxs * y1ps + rys * x1ps);</span><br><span class="line">    <span class="built_in">double</span> pq = (rxs*rys - dq) / dq;</span><br><span class="line">    <span class="built_in">double</span> q = Math.Sqrt( Math.Max(<span class="number">0</span>,pq) ); <span class="comment">//使用Max防止浮点精度问题</span></span><br><span class="line">    <span class="keyword">if</span> (flagA == flagS)</span><br><span class="line">        q = -q;</span><br><span class="line">    <span class="built_in">double</span> cxp = q * rX * y1p / rY;</span><br><span class="line">    <span class="built_in">double</span> cyp = - q * rY * x1p / rX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(F.6.5.3)</span></span><br><span class="line">    <span class="built_in">double</span> cx = Math.Cos(xAngle)*cxp - Math.Sin(xAngle)*cyp + (p1.X + p2.X)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">double</span> cy = Math.Sin(xAngle)*cxp + Math.Cos(xAngle)*cyp + (p1.Y + p2.Y)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(F.6.5.5)</span></span><br><span class="line">    <span class="built_in">double</span> theta = svgAngle( <span class="number">1</span>,<span class="number">0</span>, (x1p-cxp) / rX, (y1p - cyp)/rY );</span><br><span class="line">    <span class="comment">//(F.6.5.6)</span></span><br><span class="line">    <span class="built_in">double</span> delta = svgAngle(</span><br><span class="line">        (x1p - cxp)/rX, (y1p - cyp)/rY,</span><br><span class="line">        (-x1p - cxp)/rX, (-y1p-cyp)/rY);</span><br><span class="line">    delta = Math.Mod(delta, Math.PIf * <span class="number">2</span> );</span><br><span class="line">    <span class="keyword">if</span> (!flagS)</span><br><span class="line">        delta -= <span class="number">2</span> * Math.PIf;</span><br><span class="line"></span><br><span class="line">    r_ = float2((<span class="built_in">float</span>)rX,(<span class="built_in">float</span>)rY);</span><br><span class="line">    c = float2((<span class="built_in">float</span>)cx,(<span class="built_in">float</span>)cy);</span><br><span class="line">    angles = float2((<span class="built_in">float</span>)theta, (<span class="built_in">float</span>)delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">svgAngle</span>(<span class="params"> <span class="built_in">double</span> ux, <span class="built_in">double</span> uy, <span class="built_in">double</span> vx, <span class="built_in">double</span> vy </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> u = float2((<span class="built_in">float</span>)ux, (<span class="built_in">float</span>)uy);</span><br><span class="line">    <span class="keyword">var</span> v = float2((<span class="built_in">float</span>)vx, (<span class="built_in">float</span>)vy);</span><br><span class="line">    <span class="comment">//(F.6.5.4)</span></span><br><span class="line">    <span class="keyword">var</span> dot = Vector.Dot(u,v);</span><br><span class="line">    <span class="keyword">var</span> len = Vector.Length(u) * Vector.Length(v);</span><br><span class="line">    <span class="keyword">var</span> ang = Math.Acos( Math.Clamp(dot / len,<span class="number">-1</span>,<span class="number">1</span>) ); <span class="comment">//浮点精度误差，略微超过值</span></span><br><span class="line">    <span class="keyword">if</span> ( (u.X*v.Y - u.Y*v.X) &lt; <span class="number">0</span>)</span><br><span class="line">        ang = -ang;</span><br><span class="line">    <span class="keyword">return</span> ang;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录：JavaScript完整实现"><a href="#附录：JavaScript完整实现" class="headerlink" title="附录：JavaScript完整实现"></a>附录：JavaScript完整实现</h2><blockquote><p>本代码来自：<a href="https://stackoverflow.com/questions/43946153/approximating-svg-elliptical-arc-in-canvas-with-javascript/43952974#43952974">StackOverflow</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// M100,350</span></span><br><span class="line"><span class="comment">// a45,35 -30 0,1 50,-25</span></span><br><span class="line"></span><br><span class="line">canvas.<span class="property">width</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">canvas.<span class="property">height</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>;</span><br><span class="line">ctx.<span class="property">strokeWidth</span> = <span class="number">2</span>;</span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">&quot;#000000&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clamp</span>(<span class="params">value, min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(value, min), max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">svgAngle</span>(<span class="params">ux, uy, vx, vy </span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> dot = ux*vx + uy*vy;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(ux*ux + uy*uy) * <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(vx*vx + vy*vy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ang = <span class="title class_">Math</span>.<span class="title function_">acos</span>( <span class="title function_">clamp</span>(dot / len,-<span class="number">1</span>,<span class="number">1</span>) );</span><br><span class="line">  <span class="keyword">if</span> ( (ux*vy - uy*vx) &lt; <span class="number">0</span>)</span><br><span class="line">    ang = -ang;</span><br><span class="line">  <span class="keyword">return</span> ang;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateBezierPoints</span>(<span class="params">rx, ry, phi, flagA, flagS, x1, y1, x2, y2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> rX = <span class="title class_">Math</span>.<span class="title function_">abs</span>(rx);</span><br><span class="line">  <span class="keyword">var</span> rY = <span class="title class_">Math</span>.<span class="title function_">abs</span>(ry);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dx2 = (x1 - x2)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> dy2 = (y1 - y2)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x1p =  <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi)*dx2 + <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi)*dy2;</span><br><span class="line">  <span class="keyword">var</span> y1p = -<span class="title class_">Math</span>.<span class="title function_">sin</span>(phi)*dx2 + <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi)*dy2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> rxs = rX * rX;</span><br><span class="line">  <span class="keyword">var</span> rys = rY * rY;</span><br><span class="line">  <span class="keyword">var</span> x1ps = x1p * x1p;</span><br><span class="line">  <span class="keyword">var</span> y1ps = y1p * y1p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cr = x1ps/rxs + y1ps/rys;</span><br><span class="line">  <span class="keyword">if</span> (cr &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(cr);</span><br><span class="line">    rX = s * rX;</span><br><span class="line">    rY = s * rY;</span><br><span class="line">    rxs = rX * rX;</span><br><span class="line">    rys = rY * rY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dq = (rxs * y1ps + rys * x1ps);</span><br><span class="line">  <span class="keyword">var</span> pq = (rxs*rys - dq) / dq;</span><br><span class="line">  <span class="keyword">var</span> q = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>( <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>,pq) );</span><br><span class="line">  <span class="keyword">if</span> (flagA === flagS)</span><br><span class="line">    q = -q;</span><br><span class="line">  <span class="keyword">var</span> cxp = q * rX * y1p / rY;</span><br><span class="line">  <span class="keyword">var</span> cyp = - q * rY * x1p / rX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cx = <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi)*cxp - <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi)*cyp + (x1 + x2)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> cy = <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi)*cxp + <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi)*cyp + (y1 + y2)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> theta = <span class="title function_">svgAngle</span>( <span class="number">1</span>,<span class="number">0</span>, (x1p-cxp) / rX, (y1p - cyp)/rY );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> delta = <span class="title function_">svgAngle</span>(</span><br><span class="line">    (x1p - cxp)/rX, (y1p - cyp)/rY,</span><br><span class="line">    (-x1p - cxp)/rX, (-y1p-cyp)/rY);</span><br><span class="line"></span><br><span class="line">  delta = delta - <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">floor</span>(delta / (<span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flagS)</span><br><span class="line">    delta -= <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> n1 = theta, n2 = delta;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// E(n)</span></span><br><span class="line">  <span class="comment">// cx +acosθcosη−bsinθsinη</span></span><br><span class="line">  <span class="comment">// cy +asinθcosη+bcosθsinη</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">E</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> enx = cx + rx * <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">cos</span>(n) - ry * <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(n);</span><br><span class="line">    <span class="keyword">var</span> eny = cy + rx * <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">cos</span>(n) + ry * <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(n);</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: enx,<span class="attr">y</span>: eny&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// E&#x27;(n)</span></span><br><span class="line">  <span class="comment">// −acosθsinη−bsinθcosη</span></span><br><span class="line">  <span class="comment">// −asinθsinη+bcosθcosη</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Ed</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ednx = -<span class="number">1</span> * rx * <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(n) - ry * <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">cos</span>(n);</span><br><span class="line">    <span class="keyword">var</span> edny = -<span class="number">1</span> * rx * <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(n) + ry * <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">cos</span>(n);</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: ednx, <span class="attr">y</span>: edny&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> n = [];</span><br><span class="line">  n.<span class="title function_">push</span>(n1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> interval = <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(n[n.<span class="property">length</span> - <span class="number">1</span>] + interval &lt; n2)</span><br><span class="line">    n.<span class="title function_">push</span>(n[n.<span class="property">length</span> - <span class="number">1</span>] + interval)</span><br><span class="line"></span><br><span class="line">  n.<span class="title function_">push</span>(n2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getCP</span>(<span class="params">n1, n2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> en1 = <span class="title function_">E</span>(n1);</span><br><span class="line">    <span class="keyword">var</span> en2 = <span class="title function_">E</span>(n2);</span><br><span class="line">    <span class="keyword">var</span> edn1 = <span class="title class_">Ed</span>(n1);</span><br><span class="line">    <span class="keyword">var</span> edn2 = <span class="title class_">Ed</span>(n2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alpha = <span class="title class_">Math</span>.<span class="title function_">sin</span>(n2 - n1) * (<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">4</span> + <span class="number">3</span> * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="title class_">Math</span>.<span class="title function_">tan</span>((n2 - n1)/<span class="number">2</span>), <span class="number">2</span>)) - <span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(en1, en2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">cpx1</span>: en1.<span class="property">x</span> + alpha*edn1.<span class="property">x</span>,</span><br><span class="line">      <span class="attr">cpy1</span>: en1.<span class="property">y</span> + alpha*edn1.<span class="property">y</span>,</span><br><span class="line">      <span class="attr">cpx2</span>: en2.<span class="property">x</span> - alpha*edn2.<span class="property">x</span>,</span><br><span class="line">      <span class="attr">cpy2</span>: en2.<span class="property">y</span> - alpha*edn2.<span class="property">y</span>,</span><br><span class="line">      <span class="attr">en1</span>: en1,</span><br><span class="line">      <span class="attr">en2</span>: en2</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cps = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    cps.<span class="title function_">push</span>(<span class="title function_">getCP</span>(n[i],n[i+<span class="number">1</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// M100,100</span></span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment">// a45,35 -30 0,1 50,-25</span></span><br><span class="line"><span class="keyword">var</span> rx = <span class="number">45</span>, ry=<span class="number">35</span>,phi =  -<span class="number">30</span> * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span>, fa = <span class="number">0</span>, fs = <span class="number">1</span>, x = <span class="number">100</span>, y = <span class="number">100</span>, x1 = x + <span class="number">50</span>, y1 = y - <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cps = <span class="title function_">generateBezierPoints</span>(rx, ry, phi, fa, fs, x, y, x1, y1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> limit = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; limit &amp;&amp; i &lt; cps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(cps[i].<span class="property">cpx1</span>, cps[i].<span class="property">cpy1</span>,</span><br><span class="line">                      cps[i].<span class="property">cpx2</span>, cps[i].<span class="property">cpy2</span>,</span><br><span class="line">                      i &lt; limit - <span class="number">1</span> ? cps[i].<span class="property">en2</span>.<span class="property">x</span> : x1, i &lt; limit - <span class="number">1</span> ? cps[i].<span class="property">en2</span>.<span class="property">y</span> : y1);</span><br><span class="line">  &#125;</span><br><span class="line">ctx.<span class="title function_">stroke</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/&quot;&gt;https://mortoray.com/2017/</summary>
      
    
    
    
    
    <category term="Graphics" scheme="https://mouse0w0.github.io/tags/Graphics/"/>
    
    <category term="Math" scheme="https://mouse0w0.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>介绍 AutoHotkey</title>
    <link href="https://mouse0w0.github.io/2018/10/13/Introduce-AutoHotkey/"/>
    <id>https://mouse0w0.github.io/2018/10/13/Introduce-AutoHotkey/</id>
    <published>2018-10-13T13:03:48.000Z</published>
    <updated>2025-05-20T11:48:56.952Z</updated>
    
    <content type="html"><![CDATA[<p>此前我们介绍了Windows Scripting Host，但它的功能也并不是很强大而且并不好写。经过我的搜索，我在网上发现了更好的解决方案，那就是<strong>AutoHotkey</strong>。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>是一款免费的、Windows平台下开放源代码的热键脚本语言，是为游戏操纵杆和鼠标创建的热键，是自动按键。也可以通过命令调用系统接口及程序，并创建基于简单语言的图形化界面的执行程序。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://www.autohotkey.com/">官方网站</a></li><li><a href="https://www.autohotkey.com/docs/AutoHotkey.htm">开发文档</a></li><li><a href="https://github.com/Lexikos/AutoHotkey_L">GitHub仓库</a></li><li><a href="https://ahkscript.github.io/">GitHub组织网站</a></li><li><a href="https://github.com/ahkscript/awesome-AutoHotkey">Awesome</a></li></ul><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><ul><li><a href="https://github.com/fincs/Ahk2Exe">AHK转EXE</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此前我们介绍了Windows Scripting Host，但它的功能也并不是很强大而且并不好写。经过我的搜索，我在网上发现了更好的解决方案，那就是&lt;strong&gt;AutoHotkey&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; clas</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://mouse0w0.github.io/tags/Windows/"/>
    
    <category term="Script" scheme="https://mouse0w0.github.io/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>介绍 Windows Scripting Host</title>
    <link href="https://mouse0w0.github.io/2018/10/13/Introduce-Windows-Scripting-Host/"/>
    <id>https://mouse0w0.github.io/2018/10/13/Introduce-Windows-Scripting-Host/</id>
    <published>2018-10-13T06:08:31.000Z</published>
    <updated>2025-05-20T11:48:56.953Z</updated>
    
    <content type="html"><![CDATA[<p>近日为了使用脚本创建快捷方式，特地查阅了相关资料，最终寻找到了Windows下隐藏的实用功能。它就是<strong>Windows Scripting Host</strong>。</p><blockquote><p>WSH 是“Windows Scripting Host”的缩略形式，其通用的中文译名为“Windows脚本宿主”。对于这个较为抽象的名词，我们可以先作这样一个笼统的理解：它是内嵌于 Windows 操作系统中的脚本语言工作环境。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows Scripting Host 这个概念最早出现于 Windows 98 操作系统。大家一定还记得 MS-Dos 下的批处理命令，它曾有效地简化了我们的工作、带给我们方便，这一点就有点类似于如今大行其道的脚本语言。但就算我们把批处理命令看成是一种脚本语言，那它也是 98 版之前的 Windows 操作系统所唯一支持的“脚本语言”。而此后随着各种真正的脚本语言不断出现，批处理命令显然就很是力不从心了。面临这一危机，微软在研发 Windows 98 时，为了实现多类脚本文件在 Windows 界面或 Dos 命令提示符下的直接运行，就在系统内植入了一个基于 32 位 Windows 平台、并独立于语言的脚本运行环境，并将其命名为“Windows Scripting Host”，WSH 架构于 ActiveX 之上，通过充当 ActiveX 的脚本引擎控制器，WSH 为 Windows 用户充分利用威力强大的脚本指令语言扫清了障碍。</p><p>再具体一点描述：你自己编写了一个脚本文件，如后缀为 .vbs 或 .js 的文件，然后在 Windows 下双击并执行它，这时，系统就会自动调用一个适当的程序来对它进行解释并执行，而这个程序，就是 Windows Scripting Host，程序执行文件名为 Wscript.exe （若是在命令行下，则为 Cscript.exe）。</p><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul><li><a href="https://msdn.microsoft.com/en-us/library/at5ydy31">WScript</a></li><li><a href="https://msdn.microsoft.com/en-us/library/aew9yb99">WScript.Shell</a></li></ul><h2 id="wsh-文件运行脚本"><a href="#wsh-文件运行脚本" class="headerlink" title=".wsh 文件运行脚本"></a>.wsh 文件运行脚本</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[ScriptFile]</span></span><br><span class="line"><span class="attr">Path</span>=C:/YourScript.vbs</span><br><span class="line"></span><br><span class="line"><span class="section">[Options]</span></span><br><span class="line"><span class="attr">Timeout</span>=<span class="number">25</span></span><br><span class="line"><span class="attr">DisplayLogo</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="实战：创建桌面快捷方式"><a href="#实战：创建桌面快捷方式" class="headerlink" title="实战：创建桌面快捷方式"></a>实战：创建桌面快捷方式</h2><p>VBScript（.vbs)实现：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CurrentPath = WScript.CreateObject(<span class="string">&quot;Scripting.FileSystemObject&quot;</span>).GetFolder(<span class="string">&quot;.&quot;</span>).Path</span><br><span class="line"><span class="keyword">SET</span> WshShell = WScript.CreateObject(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">Desktop = WshShell.SpecialFolders(<span class="string">&quot;Desktop&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> oShellLink = WshShell.CreateShortcut(CurrentPath &amp; <span class="string">&quot;\Notepad.lnk&quot;</span>)</span><br><span class="line">oShellLink.TargetPath = <span class="string">&quot;notepad.exe&quot;</span></span><br><span class="line">oShellLink.WindowStyle = <span class="number">1</span></span><br><span class="line">oShellLink.Description = <span class="string">&quot;Notepad&quot;</span></span><br><span class="line">oShellLink.WorkingDirectory = Desktop</span><br><span class="line">oShellLink.Save</span><br><span class="line"></span><br><span class="line">CompletedMessage = <span class="string">&quot;Completed&quot;</span></span><br><span class="line">WScript.echo CompletedMessage</span><br></pre></td></tr></table></figure><p>JScript(.js)实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">WshShell</span> = <span class="title class_">WScript</span>.<span class="title class_">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Desktop</span> = <span class="title class_">WshShell</span>.<span class="title class_">SpecialFolders</span>(<span class="string">&quot;Desktop&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> oShellLink = <span class="title class_">WshShell</span>.<span class="title class_">CreateShortcut</span>(<span class="title class_">Desktop</span> + <span class="string">&quot;\\Notepad.lnk&quot;</span>)</span><br><span class="line">oShellLink.<span class="property">TargetPath</span> = <span class="string">&quot;notepad.exe&quot;</span>;</span><br><span class="line">oShellLink.<span class="property">WindowStyle</span> = <span class="number">1</span>;</span><br><span class="line">oShellLink.<span class="property">Description</span> = <span class="string">&quot;Notepad&quot;</span>;</span><br><span class="line">oShellLink.<span class="property">WorkingDirectory</span> = <span class="title class_">Desktop</span>;</span><br><span class="line">oShellLink.<span class="title class_">Save</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">WScript</span>.<span class="title function_">echo</span>(<span class="string">&quot;Completed&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="wsf-文件"><a href="#wsf-文件" class="headerlink" title=".wsf 文件"></a>.wsf 文件</h2><p>此外，还可以使用.wsf文件，这是一个XML格式的文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">job</span> <span class="attr">id</span>=<span class="string">&quot;vbs&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;VBScript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         set <span class="title class_">WshShell</span> = <span class="title class_">WScript</span>.<span class="title class_">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">         strDesktop = <span class="title class_">WshShell</span>.<span class="title class_">SpecialFolders</span>(<span class="string">&quot;Desktop&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">         set oShellLink = <span class="title class_">WshShell</span>.<span class="title class_">CreateShortcut</span>(strDesktop &amp; <span class="string">&quot;\Shortcut Script.lnk&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">TargetPath</span> = <span class="title class_">WScript</span>.<span class="property">ScriptFullName</span></span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">WindowStyle</span> = <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">Hotkey</span> = <span class="string">&quot;CTRL+SHIFT+F&quot;</span></span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">IconLocation</span> = <span class="string">&quot;notepad.exe, 0&quot;</span></span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">Description</span> = <span class="string">&quot;Shortcut Script&quot;</span></span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">WorkingDirectory</span> = strDesktop</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">Save</span></span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">job</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">job</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JScript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">var</span> <span class="title class_">WshShell</span> = <span class="title class_">WScript</span>.<span class="title class_">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">         strDesktop = <span class="title class_">WshShell</span>.<span class="title class_">SpecialFolders</span>(<span class="string">&quot;Desktop&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">var</span> oShellLink = <span class="title class_">WshShell</span>.<span class="title class_">CreateShortcut</span>(strDesktop + <span class="string">&quot;\\Shortcut Script.lnk&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">TargetPath</span> = <span class="title class_">WScript</span>.<span class="property">ScriptFullName</span>;</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">WindowStyle</span> = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">Hotkey</span> = <span class="string">&quot;CTRL+SHIFT+F&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">IconLocation</span> = <span class="string">&quot;notepad.exe, 0&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">Description</span> = <span class="string">&quot;Shortcut Script&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="property">WorkingDirectory</span> = strDesktop;</span></span><br><span class="line"><span class="language-javascript">         oShellLink.<span class="title class_">Save</span>();</span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">job</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近日为了使用脚本创建快捷方式，特地查阅了相关资料，最终寻找到了Windows下隐藏的实用功能。它就是&lt;strong&gt;Windows Scripting Host&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WSH 是“Windows Scripting Ho</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://mouse0w0.github.io/tags/Windows/"/>
    
    <category term="Script" scheme="https://mouse0w0.github.io/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>使用VSCode扩展REST Client发送HTTP请求</title>
    <link href="https://mouse0w0.github.io/2018/10/10/Using-VSCode-extension-RESTClient-to-send-HTTP-requests/"/>
    <id>https://mouse0w0.github.io/2018/10/10/Using-VSCode-extension-RESTClient-to-send-HTTP-requests/</id>
    <published>2018-10-10T14:54:51.000Z</published>
    <updated>2025-05-20T11:48:56.965Z</updated>
    
    <content type="html"><![CDATA[<p>最近在参加<a href="https://hack.lug.ustc.edu.cn/">中国科学技术大学第五届信息安全大赛</a>时，经高人指点，本渣找到了一款比Postman要方便（个人认为）的发送HTTP请求的工具，就是VSCode扩展<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST Client</a>，特此写博客记述一下。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>非常简单，在VSCode按<code>F1</code>，输入<code>ext install</code>后搜索<code>rest-client</code>即可。</p><h2 id="简单GET"><a href="#简单GET" class="headerlink" title="简单GET"></a>简单GET</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://example.com/comments/1 HTTP/1.1</span><br></pre></td></tr></table></figure><p>然后使用快捷键<code>Ctrl+Alt+R</code>即可运行，结果将会显示在右栏。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>REST Client还有Java应用程序版本，Github地址在此：<a href="https://github.com/wiztools/rest-client">https://github.com/wiztools/rest-client</a>。</p><p>不多说其实它还有更多实现，不过就在此不做更多介绍了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在参加&lt;a href=&quot;https://hack.lug.ustc.edu.cn/&quot;&gt;中国科学技术大学第五届信息安全大赛&lt;/a&gt;时，经高人指点，本渣找到了一款比Postman要方便（个人认为）的发送HTTP请求的工具，就是VSCode扩展&lt;a href=&quot;https:/</summary>
      
    
    
    
    
    <category term="Tool" scheme="https://mouse0w0.github.io/tags/Tool/"/>
    
    <category term="Web" scheme="https://mouse0w0.github.io/tags/Web/"/>
    
  </entry>
  
</feed>
